import {
  Accent_default,
  Blues_default,
  BrBG_default,
  BuGn_default,
  BuPu_default,
  Dark2_default,
  GnBu_default,
  Greens_default,
  Greys_default,
  OrRd_default,
  Oranges_default,
  PRGn_default,
  Paired_default,
  Pastel1_default,
  Pastel2_default,
  PiYG_default,
  PuBuGn_default,
  PuBu_default,
  PuOr_default,
  PuRd_default,
  Purples_default,
  RdBu_default,
  RdGy_default,
  RdPu_default,
  RdYlBu_default,
  RdYlGn_default,
  Reds_default,
  Set1_default,
  Set2_default,
  Set3_default,
  Spectral_default,
  Tableau10_default,
  YlGnBu_default,
  YlGn_default,
  YlOrBr_default,
  YlOrRd_default,
  category10_default,
  cividis_default,
  cool,
  cubehelix_default,
  hierarchy,
  inferno,
  init_src as init_src5,
  init_src2 as init_src6,
  magma,
  partition_default,
  plasma,
  rainbow_default,
  scheme,
  scheme10,
  scheme11,
  scheme12,
  scheme13,
  scheme14,
  scheme15,
  scheme16,
  scheme17,
  scheme18,
  scheme19,
  scheme2,
  scheme20,
  scheme21,
  scheme22,
  scheme23,
  scheme24,
  scheme25,
  scheme26,
  scheme27,
  scheme3,
  scheme4,
  scheme5,
  scheme6,
  scheme7,
  scheme8,
  scheme9,
  sinebow_default,
  turbo_default,
  viridis_default,
  warm
} from "./chunk-KTYPAP54.js";
import {
  require_arrayIncludes,
  require_arrayIncludesWith,
  require_arrayMap,
  require_assignValue,
  require_baseAssignValue,
  require_baseClone,
  require_baseFor,
  require_baseGet,
  require_baseRest,
  require_castPath,
  require_cloneBuffer,
  require_cloneTypedArray,
  require_copyArray,
  require_copyObject,
  require_flatRest,
  require_get,
  require_hasIn,
  require_initCloneObject,
  require_isIterateeCall,
  require_isPlainObject,
  require_isString,
  require_keysIn,
  require_last,
  require_sortBy,
  require_toKey
} from "./chunk-Y2XYYHXI.js";
import {
  arc_default,
  ascending_default,
  basisClosed_default2 as basisClosed_default,
  basisOpen_default,
  basis_default2 as basis_default,
  bundle_default,
  cardinalClosed_default,
  cardinalOpen_default,
  cardinal_default,
  catmullRomClosed_default,
  catmullRomOpen_default,
  catmullRom_default,
  descending_default,
  diverging_default,
  expand_default,
  init_src,
  init_src2,
  init_src4 as init_src3,
  init_src9 as init_src4,
  insideOut_default,
  line_default,
  linearClosed_default,
  linear_default,
  monotoneX,
  monotoneY,
  natural_default,
  none_default,
  none_default2,
  ordinal,
  require_SetCache,
  require_Stack,
  require_baseUnary,
  require_cacheHas,
  require_eq,
  require_isArguments,
  require_isArray,
  require_isArrayLike,
  require_isBuffer,
  require_isEqual,
  require_isFunction,
  require_isIndex,
  require_isObject,
  require_isObjectLike,
  require_isTypedArray,
  reverse_default,
  rgb,
  silhouette_default,
  stepAfter,
  stepBefore,
  step_default,
  wiggle_default
} from "./chunk-TFK3GYAU.js";
import {
  require_jsx_runtime
} from "./chunk-VTIQK5XW.js";
import {
  require_react_dom
} from "./chunk-Y5BGZF4O.js";
import {
  require_react
} from "./chunk-H5FQS3OF.js";
import {
  __commonJS,
  __toESM
} from "./chunk-V4OQ3NZ2.js";

// node_modules/lodash/_assignMergeValue.js
var require_assignMergeValue = __commonJS({
  "node_modules/lodash/_assignMergeValue.js"(exports, module) {
    var baseAssignValue = require_baseAssignValue();
    var eq = require_eq();
    function assignMergeValue(object, key, value) {
      if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    module.exports = assignMergeValue;
  }
});

// node_modules/lodash/isArrayLikeObject.js
var require_isArrayLikeObject = __commonJS({
  "node_modules/lodash/isArrayLikeObject.js"(exports, module) {
    var isArrayLike = require_isArrayLike();
    var isObjectLike = require_isObjectLike();
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    module.exports = isArrayLikeObject;
  }
});

// node_modules/lodash/_safeGet.js
var require_safeGet = __commonJS({
  "node_modules/lodash/_safeGet.js"(exports, module) {
    function safeGet(object, key) {
      if (key === "constructor" && typeof object[key] === "function") {
        return;
      }
      if (key == "__proto__") {
        return;
      }
      return object[key];
    }
    module.exports = safeGet;
  }
});

// node_modules/lodash/toPlainObject.js
var require_toPlainObject = __commonJS({
  "node_modules/lodash/toPlainObject.js"(exports, module) {
    var copyObject = require_copyObject();
    var keysIn = require_keysIn();
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }
    module.exports = toPlainObject;
  }
});

// node_modules/lodash/_baseMergeDeep.js
var require_baseMergeDeep = __commonJS({
  "node_modules/lodash/_baseMergeDeep.js"(exports, module) {
    var assignMergeValue = require_assignMergeValue();
    var cloneBuffer = require_cloneBuffer();
    var cloneTypedArray = require_cloneTypedArray();
    var copyArray = require_copyArray();
    var initCloneObject = require_initCloneObject();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isArrayLikeObject = require_isArrayLikeObject();
    var isBuffer = require_isBuffer();
    var isFunction = require_isFunction();
    var isObject = require_isObject();
    var isPlainObject = require_isPlainObject();
    var isTypedArray = require_isTypedArray();
    var safeGet = require_safeGet();
    var toPlainObject = require_toPlainObject();
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          } else {
            newValue = [];
          }
        } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack["delete"](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }
    module.exports = baseMergeDeep;
  }
});

// node_modules/lodash/_baseMerge.js
var require_baseMerge = __commonJS({
  "node_modules/lodash/_baseMerge.js"(exports, module) {
    var Stack = require_Stack();
    var assignMergeValue = require_assignMergeValue();
    var baseFor = require_baseFor();
    var baseMergeDeep = require_baseMergeDeep();
    var isObject = require_isObject();
    var keysIn = require_keysIn();
    var safeGet = require_safeGet();
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack());
        if (isObject(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        } else {
          var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }
    module.exports = baseMerge;
  }
});

// node_modules/lodash/_createAssigner.js
var require_createAssigner = __commonJS({
  "node_modules/lodash/_createAssigner.js"(exports, module) {
    var baseRest = require_baseRest();
    var isIterateeCall = require_isIterateeCall();
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index2 < length) {
          var source = sources[index2];
          if (source) {
            assigner(object, source, index2, customizer);
          }
        }
        return object;
      });
    }
    module.exports = createAssigner;
  }
});

// node_modules/lodash/merge.js
var require_merge = __commonJS({
  "node_modules/lodash/merge.js"(exports, module) {
    var baseMerge = require_baseMerge();
    var createAssigner = require_createAssigner();
    var merge2 = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });
    module.exports = merge2;
  }
});

// node_modules/lodash/_baseSet.js
var require_baseSet = __commonJS({
  "node_modules/lodash/_baseSet.js"(exports, module) {
    var assignValue = require_assignValue();
    var castPath = require_castPath();
    var isIndex = require_isIndex();
    var isObject = require_isObject();
    var toKey = require_toKey();
    function baseSet(object, path, value, customizer) {
      if (!isObject(object)) {
        return object;
      }
      path = castPath(path, object);
      var index2 = -1, length = path.length, lastIndex = length - 1, nested = object;
      while (nested != null && ++index2 < length) {
        var key = toKey(path[index2]), newValue = value;
        if (key === "__proto__" || key === "constructor" || key === "prototype") {
          return object;
        }
        if (index2 != lastIndex) {
          var objValue = nested[key];
          newValue = customizer ? customizer(objValue, key, nested) : void 0;
          if (newValue === void 0) {
            newValue = isObject(objValue) ? objValue : isIndex(path[index2 + 1]) ? [] : {};
          }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
      }
      return object;
    }
    module.exports = baseSet;
  }
});

// node_modules/lodash/set.js
var require_set = __commonJS({
  "node_modules/lodash/set.js"(exports, module) {
    var baseSet = require_baseSet();
    function set2(object, path, value) {
      return object == null ? object : baseSet(object, path, value);
    }
    module.exports = set2;
  }
});

// node_modules/lodash/_baseDifference.js
var require_baseDifference = __commonJS({
  "node_modules/lodash/_baseDifference.js"(exports, module) {
    var SetCache = require_SetCache();
    var arrayIncludes = require_arrayIncludes();
    var arrayIncludesWith = require_arrayIncludesWith();
    var arrayMap = require_arrayMap();
    var baseUnary = require_baseUnary();
    var cacheHas = require_cacheHas();
    var LARGE_ARRAY_SIZE = 200;
    function baseDifference(array2, values, iteratee, comparator) {
      var index2 = -1, includes = arrayIncludes, isCommon = true, length = array2.length, result = [], valuesLength = values.length;
      if (!length) {
        return result;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      } else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer:
        while (++index2 < length) {
          var value = array2[index2], computed = iteratee == null ? value : iteratee(value);
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var valuesIndex = valuesLength;
            while (valuesIndex--) {
              if (values[valuesIndex] === computed) {
                continue outer;
              }
            }
            result.push(value);
          } else if (!includes(values, computed, comparator)) {
            result.push(value);
          }
        }
      return result;
    }
    module.exports = baseDifference;
  }
});

// node_modules/lodash/without.js
var require_without = __commonJS({
  "node_modules/lodash/without.js"(exports, module) {
    var baseDifference = require_baseDifference();
    var baseRest = require_baseRest();
    var isArrayLikeObject = require_isArrayLikeObject();
    var without = baseRest(function(array2, values) {
      return isArrayLikeObject(array2) ? baseDifference(array2, values) : [];
    });
    module.exports = without;
  }
});

// node_modules/lodash/_basePickBy.js
var require_basePickBy = __commonJS({
  "node_modules/lodash/_basePickBy.js"(exports, module) {
    var baseGet = require_baseGet();
    var baseSet = require_baseSet();
    var castPath = require_castPath();
    function basePickBy(object, paths, predicate) {
      var index2 = -1, length = paths.length, result = {};
      while (++index2 < length) {
        var path = paths[index2], value = baseGet(object, path);
        if (predicate(value, path)) {
          baseSet(result, castPath(path, object), value);
        }
      }
      return result;
    }
    module.exports = basePickBy;
  }
});

// node_modules/lodash/_basePick.js
var require_basePick = __commonJS({
  "node_modules/lodash/_basePick.js"(exports, module) {
    var basePickBy = require_basePickBy();
    var hasIn = require_hasIn();
    function basePick(object, paths) {
      return basePickBy(object, paths, function(value, path) {
        return hasIn(object, path);
      });
    }
    module.exports = basePick;
  }
});

// node_modules/lodash/pick.js
var require_pick = __commonJS({
  "node_modules/lodash/pick.js"(exports, module) {
    var basePick = require_basePick();
    var flatRest = require_flatRest();
    var pick = flatRest(function(object, paths) {
      return object == null ? {} : basePick(object, paths);
    });
    module.exports = pick;
  }
});

// node_modules/lodash/cloneDeep.js
var require_cloneDeep = __commonJS({
  "node_modules/lodash/cloneDeep.js"(exports, module) {
    var baseClone = require_baseClone();
    var CLONE_DEEP_FLAG = 1;
    var CLONE_SYMBOLS_FLAG = 4;
    function cloneDeep(value) {
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
    }
    module.exports = cloneDeep;
  }
});

// node_modules/@nivo/sunburst/dist/nivo-sunburst.mjs
var import_react22 = __toESM(require_react(), 1);

// node_modules/@nivo/core/dist/nivo-core.mjs
var import_react19 = __toESM(require_react(), 1);

// node_modules/@nivo/tooltip/dist/nivo-tooltip.mjs
var import_react16 = __toESM(require_react(), 1);

// node_modules/@react-spring/rafz/dist/react-spring_rafz.modern.mjs
var updateQueue = makeQueue();
var raf = (fn3) => schedule(fn3, updateQueue);
var writeQueue = makeQueue();
raf.write = (fn3) => schedule(fn3, writeQueue);
var onStartQueue = makeQueue();
raf.onStart = (fn3) => schedule(fn3, onStartQueue);
var onFrameQueue = makeQueue();
raf.onFrame = (fn3) => schedule(fn3, onFrameQueue);
var onFinishQueue = makeQueue();
raf.onFinish = (fn3) => schedule(fn3, onFinishQueue);
var timeouts = [];
raf.setTimeout = (handler, ms) => {
  const time = raf.now() + ms;
  const cancel = () => {
    const i6 = timeouts.findIndex((t5) => t5.cancel == cancel);
    if (~i6) timeouts.splice(i6, 1);
    pendingCount -= ~i6 ? 1 : 0;
  };
  const timeout = { time, handler, cancel };
  timeouts.splice(findTimeout(time), 0, timeout);
  pendingCount += 1;
  start();
  return timeout;
};
var findTimeout = (time) => ~(~timeouts.findIndex((t5) => t5.time > time) || ~timeouts.length);
raf.cancel = (fn3) => {
  onStartQueue.delete(fn3);
  onFrameQueue.delete(fn3);
  onFinishQueue.delete(fn3);
  updateQueue.delete(fn3);
  writeQueue.delete(fn3);
};
raf.sync = (fn3) => {
  sync = true;
  raf.batchedUpdates(fn3);
  sync = false;
};
raf.throttle = (fn3) => {
  let lastArgs;
  function queuedFn() {
    try {
      fn3(...lastArgs);
    } finally {
      lastArgs = null;
    }
  }
  function throttled(...args) {
    lastArgs = args;
    raf.onStart(queuedFn);
  }
  throttled.handler = fn3;
  throttled.cancel = () => {
    onStartQueue.delete(queuedFn);
    lastArgs = null;
  };
  return throttled;
};
var nativeRaf = typeof window != "undefined" ? window.requestAnimationFrame : (
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  () => {
  }
);
raf.use = (impl) => nativeRaf = impl;
raf.now = typeof performance != "undefined" ? () => performance.now() : Date.now;
raf.batchedUpdates = (fn3) => fn3();
raf.catch = console.error;
raf.frameLoop = "always";
raf.advance = () => {
  if (raf.frameLoop !== "demand") {
    console.warn(
      "Cannot call the manual advancement of rafz whilst frameLoop is not set as demand"
    );
  } else {
    update();
  }
};
var ts = -1;
var pendingCount = 0;
var sync = false;
function schedule(fn3, queue) {
  if (sync) {
    queue.delete(fn3);
    fn3(0);
  } else {
    queue.add(fn3);
    start();
  }
}
function start() {
  if (ts < 0) {
    ts = 0;
    if (raf.frameLoop !== "demand") {
      nativeRaf(loop);
    }
  }
}
function stop() {
  ts = -1;
}
function loop() {
  if (~ts) {
    nativeRaf(loop);
    raf.batchedUpdates(update);
  }
}
function update() {
  const prevTs = ts;
  ts = raf.now();
  const count2 = findTimeout(ts);
  if (count2) {
    eachSafely(timeouts.splice(0, count2), (t5) => t5.handler());
    pendingCount -= count2;
  }
  if (!pendingCount) {
    stop();
    return;
  }
  onStartQueue.flush();
  updateQueue.flush(prevTs ? Math.min(64, ts - prevTs) : 16.667);
  onFrameQueue.flush();
  writeQueue.flush();
  onFinishQueue.flush();
}
function makeQueue() {
  let next = /* @__PURE__ */ new Set();
  let current = next;
  return {
    add(fn3) {
      pendingCount += current == next && !next.has(fn3) ? 1 : 0;
      next.add(fn3);
    },
    delete(fn3) {
      pendingCount -= current == next && next.has(fn3) ? 1 : 0;
      return next.delete(fn3);
    },
    flush(arg) {
      if (current.size) {
        next = /* @__PURE__ */ new Set();
        pendingCount -= current.size;
        eachSafely(current, (fn3) => fn3(arg) && next.add(fn3));
        pendingCount += next.size;
        current = next;
      }
    }
  };
}
function eachSafely(values, each2) {
  values.forEach((value) => {
    try {
      each2(value);
    } catch (e8) {
      raf.catch(e8);
    }
  });
}

// node_modules/@react-spring/shared/dist/react-spring_shared.modern.mjs
var import_react = __toESM(require_react(), 1);
var import_react2 = __toESM(require_react(), 1);
var import_react3 = __toESM(require_react(), 1);
var import_react4 = __toESM(require_react(), 1);
var import_react5 = __toESM(require_react(), 1);
var import_react6 = __toESM(require_react(), 1);
var import_react7 = __toESM(require_react(), 1);
var import_react8 = __toESM(require_react(), 1);
var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var globals_exports = {};
__export(globals_exports, {
  assign: () => assign,
  colors: () => colors,
  createStringInterpolator: () => createStringInterpolator,
  skipAnimation: () => skipAnimation,
  to: () => to,
  willAdvance: () => willAdvance
});
function noop() {
}
var defineHidden = (obj, key, value) => Object.defineProperty(obj, key, { value, writable: true, configurable: true });
var is = {
  arr: Array.isArray,
  obj: (a4) => !!a4 && a4.constructor.name === "Object",
  fun: (a4) => typeof a4 === "function",
  str: (a4) => typeof a4 === "string",
  num: (a4) => typeof a4 === "number",
  und: (a4) => a4 === void 0
};
function isEqual(a4, b5) {
  if (is.arr(a4)) {
    if (!is.arr(b5) || a4.length !== b5.length) return false;
    for (let i6 = 0; i6 < a4.length; i6++) {
      if (a4[i6] !== b5[i6]) return false;
    }
    return true;
  }
  return a4 === b5;
}
var each = (obj, fn3) => obj.forEach(fn3);
function eachProp(obj, fn3, ctx) {
  if (is.arr(obj)) {
    for (let i6 = 0; i6 < obj.length; i6++) {
      fn3.call(ctx, obj[i6], `${i6}`);
    }
    return;
  }
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      fn3.call(ctx, obj[key], key);
    }
  }
}
var toArray = (a4) => is.und(a4) ? [] : is.arr(a4) ? a4 : [a4];
function flush(queue, iterator) {
  if (queue.size) {
    const items = Array.from(queue);
    queue.clear();
    each(items, iterator);
  }
}
var flushCalls = (queue, ...args) => flush(queue, (fn3) => fn3(...args));
var isSSR = () => typeof window === "undefined" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent);
var createStringInterpolator;
var to;
var colors = null;
var skipAnimation = false;
var willAdvance = noop;
var assign = (globals) => {
  if (globals.to) to = globals.to;
  if (globals.now) raf.now = globals.now;
  if (globals.colors !== void 0) colors = globals.colors;
  if (globals.skipAnimation != null) skipAnimation = globals.skipAnimation;
  if (globals.createStringInterpolator)
    createStringInterpolator = globals.createStringInterpolator;
  if (globals.requestAnimationFrame) raf.use(globals.requestAnimationFrame);
  if (globals.batchedUpdates) raf.batchedUpdates = globals.batchedUpdates;
  if (globals.willAdvance) willAdvance = globals.willAdvance;
  if (globals.frameLoop) raf.frameLoop = globals.frameLoop;
};
var startQueue = /* @__PURE__ */ new Set();
var currentFrame = [];
var prevFrame = [];
var priority = 0;
var frameLoop = {
  get idle() {
    return !startQueue.size && !currentFrame.length;
  },
  /** Advance the given animation on every frame until idle. */
  start(animation) {
    if (priority > animation.priority) {
      startQueue.add(animation);
      raf.onStart(flushStartQueue);
    } else {
      startSafely(animation);
      raf(advance);
    }
  },
  /** Advance all animations by the given time. */
  advance,
  /** Call this when an animation's priority changes. */
  sort(animation) {
    if (priority) {
      raf.onFrame(() => frameLoop.sort(animation));
    } else {
      const prevIndex = currentFrame.indexOf(animation);
      if (~prevIndex) {
        currentFrame.splice(prevIndex, 1);
        startUnsafely(animation);
      }
    }
  },
  /**
   * Clear all animations. For testing purposes.
   *
   * ☠️ Never call this from within the frameloop.
   */
  clear() {
    currentFrame = [];
    startQueue.clear();
  }
};
function flushStartQueue() {
  startQueue.forEach(startSafely);
  startQueue.clear();
  raf(advance);
}
function startSafely(animation) {
  if (!currentFrame.includes(animation)) startUnsafely(animation);
}
function startUnsafely(animation) {
  currentFrame.splice(
    findIndex(currentFrame, (other) => other.priority > animation.priority),
    0,
    animation
  );
}
function advance(dt2) {
  const nextFrame = prevFrame;
  for (let i6 = 0; i6 < currentFrame.length; i6++) {
    const animation = currentFrame[i6];
    priority = animation.priority;
    if (!animation.idle) {
      willAdvance(animation);
      animation.advance(dt2);
      if (!animation.idle) {
        nextFrame.push(animation);
      }
    }
  }
  priority = 0;
  prevFrame = currentFrame;
  prevFrame.length = 0;
  currentFrame = nextFrame;
  return currentFrame.length > 0;
}
function findIndex(arr, test) {
  const index2 = arr.findIndex(test);
  return index2 < 0 ? arr.length : index2;
}
var clamp = (min2, max2, v2) => Math.min(Math.max(v2, min2), max2);
var colors2 = {
  transparent: 0,
  aliceblue: 4042850303,
  antiquewhite: 4209760255,
  aqua: 16777215,
  aquamarine: 2147472639,
  azure: 4043309055,
  beige: 4126530815,
  bisque: 4293182719,
  black: 255,
  blanchedalmond: 4293643775,
  blue: 65535,
  blueviolet: 2318131967,
  brown: 2771004159,
  burlywood: 3736635391,
  burntsienna: 3934150143,
  cadetblue: 1604231423,
  chartreuse: 2147418367,
  chocolate: 3530104575,
  coral: 4286533887,
  cornflowerblue: 1687547391,
  cornsilk: 4294499583,
  crimson: 3692313855,
  cyan: 16777215,
  darkblue: 35839,
  darkcyan: 9145343,
  darkgoldenrod: 3095792639,
  darkgray: 2846468607,
  darkgreen: 6553855,
  darkgrey: 2846468607,
  darkkhaki: 3182914559,
  darkmagenta: 2332068863,
  darkolivegreen: 1433087999,
  darkorange: 4287365375,
  darkorchid: 2570243327,
  darkred: 2332033279,
  darksalmon: 3918953215,
  darkseagreen: 2411499519,
  darkslateblue: 1211993087,
  darkslategray: 793726975,
  darkslategrey: 793726975,
  darkturquoise: 13554175,
  darkviolet: 2483082239,
  deeppink: 4279538687,
  deepskyblue: 12582911,
  dimgray: 1768516095,
  dimgrey: 1768516095,
  dodgerblue: 512819199,
  firebrick: 2988581631,
  floralwhite: 4294635775,
  forestgreen: 579543807,
  fuchsia: 4278255615,
  gainsboro: 3705462015,
  ghostwhite: 4177068031,
  gold: 4292280575,
  goldenrod: 3668254975,
  gray: 2155905279,
  green: 8388863,
  greenyellow: 2919182335,
  grey: 2155905279,
  honeydew: 4043305215,
  hotpink: 4285117695,
  indianred: 3445382399,
  indigo: 1258324735,
  ivory: 4294963455,
  khaki: 4041641215,
  lavender: 3873897215,
  lavenderblush: 4293981695,
  lawngreen: 2096890111,
  lemonchiffon: 4294626815,
  lightblue: 2916673279,
  lightcoral: 4034953471,
  lightcyan: 3774873599,
  lightgoldenrodyellow: 4210742015,
  lightgray: 3553874943,
  lightgreen: 2431553791,
  lightgrey: 3553874943,
  lightpink: 4290167295,
  lightsalmon: 4288707327,
  lightseagreen: 548580095,
  lightskyblue: 2278488831,
  lightslategray: 2005441023,
  lightslategrey: 2005441023,
  lightsteelblue: 2965692159,
  lightyellow: 4294959359,
  lime: 16711935,
  limegreen: 852308735,
  linen: 4210091775,
  magenta: 4278255615,
  maroon: 2147483903,
  mediumaquamarine: 1724754687,
  mediumblue: 52735,
  mediumorchid: 3126187007,
  mediumpurple: 2473647103,
  mediumseagreen: 1018393087,
  mediumslateblue: 2070474495,
  mediumspringgreen: 16423679,
  mediumturquoise: 1221709055,
  mediumvioletred: 3340076543,
  midnightblue: 421097727,
  mintcream: 4127193855,
  mistyrose: 4293190143,
  moccasin: 4293178879,
  navajowhite: 4292783615,
  navy: 33023,
  oldlace: 4260751103,
  olive: 2155872511,
  olivedrab: 1804477439,
  orange: 4289003775,
  orangered: 4282712319,
  orchid: 3664828159,
  palegoldenrod: 4008225535,
  palegreen: 2566625535,
  paleturquoise: 2951671551,
  palevioletred: 3681588223,
  papayawhip: 4293907967,
  peachpuff: 4292524543,
  peru: 3448061951,
  pink: 4290825215,
  plum: 3718307327,
  powderblue: 2967529215,
  purple: 2147516671,
  rebeccapurple: 1714657791,
  red: 4278190335,
  rosybrown: 3163525119,
  royalblue: 1097458175,
  saddlebrown: 2336560127,
  salmon: 4202722047,
  sandybrown: 4104413439,
  seagreen: 780883967,
  seashell: 4294307583,
  sienna: 2689740287,
  silver: 3233857791,
  skyblue: 2278484991,
  slateblue: 1784335871,
  slategray: 1887473919,
  slategrey: 1887473919,
  snow: 4294638335,
  springgreen: 16744447,
  steelblue: 1182971135,
  tan: 3535047935,
  teal: 8421631,
  thistle: 3636451583,
  tomato: 4284696575,
  turquoise: 1088475391,
  violet: 4001558271,
  wheat: 4125012991,
  white: 4294967295,
  whitesmoke: 4126537215,
  yellow: 4294902015,
  yellowgreen: 2597139199
};
var NUMBER = "[-+]?\\d*\\.?\\d+";
var PERCENTAGE = NUMBER + "%";
function call(...parts) {
  return "\\(\\s*(" + parts.join(")\\s*,\\s*(") + ")\\s*\\)";
}
var rgb2 = new RegExp("rgb" + call(NUMBER, NUMBER, NUMBER));
var rgba = new RegExp("rgba" + call(NUMBER, NUMBER, NUMBER, NUMBER));
var hsl = new RegExp("hsl" + call(NUMBER, PERCENTAGE, PERCENTAGE));
var hsla = new RegExp(
  "hsla" + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER)
);
var hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
var hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
var hex6 = /^#([0-9a-fA-F]{6})$/;
var hex8 = /^#([0-9a-fA-F]{8})$/;
function normalizeColor(color) {
  let match;
  if (typeof color === "number") {
    return color >>> 0 === color && color >= 0 && color <= 4294967295 ? color : null;
  }
  if (match = hex6.exec(color))
    return parseInt(match[1] + "ff", 16) >>> 0;
  if (colors && colors[color] !== void 0) {
    return colors[color];
  }
  if (match = rgb2.exec(color)) {
    return (parse255(match[1]) << 24 | // r
    parse255(match[2]) << 16 | // g
    parse255(match[3]) << 8 | // b
    255) >>> // a
    0;
  }
  if (match = rgba.exec(color)) {
    return (parse255(match[1]) << 24 | // r
    parse255(match[2]) << 16 | // g
    parse255(match[3]) << 8 | // b
    parse1(match[4])) >>> // a
    0;
  }
  if (match = hex3.exec(color)) {
    return parseInt(
      match[1] + match[1] + // r
      match[2] + match[2] + // g
      match[3] + match[3] + // b
      "ff",
      // a
      16
    ) >>> 0;
  }
  if (match = hex8.exec(color)) return parseInt(match[1], 16) >>> 0;
  if (match = hex4.exec(color)) {
    return parseInt(
      match[1] + match[1] + // r
      match[2] + match[2] + // g
      match[3] + match[3] + // b
      match[4] + match[4],
      // a
      16
    ) >>> 0;
  }
  if (match = hsl.exec(color)) {
    return (hslToRgb(
      parse360(match[1]),
      // h
      parsePercentage(match[2]),
      // s
      parsePercentage(match[3])
      // l
    ) | 255) >>> // a
    0;
  }
  if (match = hsla.exec(color)) {
    return (hslToRgb(
      parse360(match[1]),
      // h
      parsePercentage(match[2]),
      // s
      parsePercentage(match[3])
      // l
    ) | parse1(match[4])) >>> // a
    0;
  }
  return null;
}
function hue2rgb(p4, q2, t5) {
  if (t5 < 0) t5 += 1;
  if (t5 > 1) t5 -= 1;
  if (t5 < 1 / 6) return p4 + (q2 - p4) * 6 * t5;
  if (t5 < 1 / 2) return q2;
  if (t5 < 2 / 3) return p4 + (q2 - p4) * (2 / 3 - t5) * 6;
  return p4;
}
function hslToRgb(h2, s5, l5) {
  const q2 = l5 < 0.5 ? l5 * (1 + s5) : l5 + s5 - l5 * s5;
  const p4 = 2 * l5 - q2;
  const r6 = hue2rgb(p4, q2, h2 + 1 / 3);
  const g2 = hue2rgb(p4, q2, h2);
  const b5 = hue2rgb(p4, q2, h2 - 1 / 3);
  return Math.round(r6 * 255) << 24 | Math.round(g2 * 255) << 16 | Math.round(b5 * 255) << 8;
}
function parse255(str) {
  const int = parseInt(str, 10);
  if (int < 0) return 0;
  if (int > 255) return 255;
  return int;
}
function parse360(str) {
  const int = parseFloat(str);
  return (int % 360 + 360) % 360 / 360;
}
function parse1(str) {
  const num = parseFloat(str);
  if (num < 0) return 0;
  if (num > 1) return 255;
  return Math.round(num * 255);
}
function parsePercentage(str) {
  const int = parseFloat(str);
  if (int < 0) return 0;
  if (int > 100) return 1;
  return int / 100;
}
function colorToRgba(input) {
  let int32Color = normalizeColor(input);
  if (int32Color === null) return input;
  int32Color = int32Color || 0;
  const r6 = (int32Color & 4278190080) >>> 24;
  const g2 = (int32Color & 16711680) >>> 16;
  const b5 = (int32Color & 65280) >>> 8;
  const a4 = (int32Color & 255) / 255;
  return `rgba(${r6}, ${g2}, ${b5}, ${a4})`;
}
var createInterpolator = (range, output, extrapolate) => {
  if (is.fun(range)) {
    return range;
  }
  if (is.arr(range)) {
    return createInterpolator({
      range,
      output,
      extrapolate
    });
  }
  if (is.str(range.output[0])) {
    return createStringInterpolator(range);
  }
  const config2 = range;
  const outputRange = config2.output;
  const inputRange = config2.range || [0, 1];
  const extrapolateLeft = config2.extrapolateLeft || config2.extrapolate || "extend";
  const extrapolateRight = config2.extrapolateRight || config2.extrapolate || "extend";
  const easing = config2.easing || ((t5) => t5);
  return (input) => {
    const range2 = findRange(input, inputRange);
    return interpolate(
      input,
      inputRange[range2],
      inputRange[range2 + 1],
      outputRange[range2],
      outputRange[range2 + 1],
      easing,
      extrapolateLeft,
      extrapolateRight,
      config2.map
    );
  };
};
function interpolate(input, inputMin, inputMax, outputMin, outputMax, easing, extrapolateLeft, extrapolateRight, map4) {
  let result = map4 ? map4(input) : input;
  if (result < inputMin) {
    if (extrapolateLeft === "identity") return result;
    else if (extrapolateLeft === "clamp") result = inputMin;
  }
  if (result > inputMax) {
    if (extrapolateRight === "identity") return result;
    else if (extrapolateRight === "clamp") result = inputMax;
  }
  if (outputMin === outputMax) return outputMin;
  if (inputMin === inputMax) return input <= inputMin ? outputMin : outputMax;
  if (inputMin === -Infinity) result = -result;
  else if (inputMax === Infinity) result = result - inputMin;
  else result = (result - inputMin) / (inputMax - inputMin);
  result = easing(result);
  if (outputMin === -Infinity) result = -result;
  else if (outputMax === Infinity) result = result + outputMin;
  else result = result * (outputMax - outputMin) + outputMin;
  return result;
}
function findRange(input, inputRange) {
  for (var i6 = 1; i6 < inputRange.length - 1; ++i6)
    if (inputRange[i6] >= input) break;
  return i6 - 1;
}
var steps = (steps2, direction = "end") => (progress2) => {
  progress2 = direction === "end" ? Math.min(progress2, 0.999) : Math.max(progress2, 1e-3);
  const expanded = progress2 * steps2;
  const rounded = direction === "end" ? Math.floor(expanded) : Math.ceil(expanded);
  return clamp(0, 1, rounded / steps2);
};
var c1 = 1.70158;
var c2 = c1 * 1.525;
var c3 = c1 + 1;
var c4 = 2 * Math.PI / 3;
var c5 = 2 * Math.PI / 4.5;
var bounceOut = (x3) => {
  const n1 = 7.5625;
  const d1 = 2.75;
  if (x3 < 1 / d1) {
    return n1 * x3 * x3;
  } else if (x3 < 2 / d1) {
    return n1 * (x3 -= 1.5 / d1) * x3 + 0.75;
  } else if (x3 < 2.5 / d1) {
    return n1 * (x3 -= 2.25 / d1) * x3 + 0.9375;
  } else {
    return n1 * (x3 -= 2.625 / d1) * x3 + 0.984375;
  }
};
var easings = {
  linear: (x3) => x3,
  easeInQuad: (x3) => x3 * x3,
  easeOutQuad: (x3) => 1 - (1 - x3) * (1 - x3),
  easeInOutQuad: (x3) => x3 < 0.5 ? 2 * x3 * x3 : 1 - Math.pow(-2 * x3 + 2, 2) / 2,
  easeInCubic: (x3) => x3 * x3 * x3,
  easeOutCubic: (x3) => 1 - Math.pow(1 - x3, 3),
  easeInOutCubic: (x3) => x3 < 0.5 ? 4 * x3 * x3 * x3 : 1 - Math.pow(-2 * x3 + 2, 3) / 2,
  easeInQuart: (x3) => x3 * x3 * x3 * x3,
  easeOutQuart: (x3) => 1 - Math.pow(1 - x3, 4),
  easeInOutQuart: (x3) => x3 < 0.5 ? 8 * x3 * x3 * x3 * x3 : 1 - Math.pow(-2 * x3 + 2, 4) / 2,
  easeInQuint: (x3) => x3 * x3 * x3 * x3 * x3,
  easeOutQuint: (x3) => 1 - Math.pow(1 - x3, 5),
  easeInOutQuint: (x3) => x3 < 0.5 ? 16 * x3 * x3 * x3 * x3 * x3 : 1 - Math.pow(-2 * x3 + 2, 5) / 2,
  easeInSine: (x3) => 1 - Math.cos(x3 * Math.PI / 2),
  easeOutSine: (x3) => Math.sin(x3 * Math.PI / 2),
  easeInOutSine: (x3) => -(Math.cos(Math.PI * x3) - 1) / 2,
  easeInExpo: (x3) => x3 === 0 ? 0 : Math.pow(2, 10 * x3 - 10),
  easeOutExpo: (x3) => x3 === 1 ? 1 : 1 - Math.pow(2, -10 * x3),
  easeInOutExpo: (x3) => x3 === 0 ? 0 : x3 === 1 ? 1 : x3 < 0.5 ? Math.pow(2, 20 * x3 - 10) / 2 : (2 - Math.pow(2, -20 * x3 + 10)) / 2,
  easeInCirc: (x3) => 1 - Math.sqrt(1 - Math.pow(x3, 2)),
  easeOutCirc: (x3) => Math.sqrt(1 - Math.pow(x3 - 1, 2)),
  easeInOutCirc: (x3) => x3 < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * x3, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * x3 + 2, 2)) + 1) / 2,
  easeInBack: (x3) => c3 * x3 * x3 * x3 - c1 * x3 * x3,
  easeOutBack: (x3) => 1 + c3 * Math.pow(x3 - 1, 3) + c1 * Math.pow(x3 - 1, 2),
  easeInOutBack: (x3) => x3 < 0.5 ? Math.pow(2 * x3, 2) * ((c2 + 1) * 2 * x3 - c2) / 2 : (Math.pow(2 * x3 - 2, 2) * ((c2 + 1) * (x3 * 2 - 2) + c2) + 2) / 2,
  easeInElastic: (x3) => x3 === 0 ? 0 : x3 === 1 ? 1 : -Math.pow(2, 10 * x3 - 10) * Math.sin((x3 * 10 - 10.75) * c4),
  easeOutElastic: (x3) => x3 === 0 ? 0 : x3 === 1 ? 1 : Math.pow(2, -10 * x3) * Math.sin((x3 * 10 - 0.75) * c4) + 1,
  easeInOutElastic: (x3) => x3 === 0 ? 0 : x3 === 1 ? 1 : x3 < 0.5 ? -(Math.pow(2, 20 * x3 - 10) * Math.sin((20 * x3 - 11.125) * c5)) / 2 : Math.pow(2, -20 * x3 + 10) * Math.sin((20 * x3 - 11.125) * c5) / 2 + 1,
  easeInBounce: (x3) => 1 - bounceOut(1 - x3),
  easeOutBounce: bounceOut,
  easeInOutBounce: (x3) => x3 < 0.5 ? (1 - bounceOut(1 - 2 * x3)) / 2 : (1 + bounceOut(2 * x3 - 1)) / 2,
  steps
};
var $get = Symbol.for("FluidValue.get");
var $observers = Symbol.for("FluidValue.observers");
var hasFluidValue = (arg) => Boolean(arg && arg[$get]);
var getFluidValue = (arg) => arg && arg[$get] ? arg[$get]() : arg;
var getFluidObservers = (target) => target[$observers] || null;
function callFluidObserver(observer2, event) {
  if (observer2.eventObserved) {
    observer2.eventObserved(event);
  } else {
    observer2(event);
  }
}
function callFluidObservers(target, event) {
  const observers = target[$observers];
  if (observers) {
    observers.forEach((observer2) => {
      callFluidObserver(observer2, event);
    });
  }
}
var FluidValue = class {
  constructor(get) {
    if (!get && !(get = this.get)) {
      throw Error("Unknown getter");
    }
    setFluidGetter(this, get);
  }
};
var setFluidGetter = (target, get) => setHidden(target, $get, get);
function addFluidObserver(target, observer2) {
  if (target[$get]) {
    let observers = target[$observers];
    if (!observers) {
      setHidden(target, $observers, observers = /* @__PURE__ */ new Set());
    }
    if (!observers.has(observer2)) {
      observers.add(observer2);
      if (target.observerAdded) {
        target.observerAdded(observers.size, observer2);
      }
    }
  }
  return observer2;
}
function removeFluidObserver(target, observer2) {
  const observers = target[$observers];
  if (observers && observers.has(observer2)) {
    const count2 = observers.size - 1;
    if (count2) {
      observers.delete(observer2);
    } else {
      target[$observers] = null;
    }
    if (target.observerRemoved) {
      target.observerRemoved(count2, observer2);
    }
  }
}
var setHidden = (target, key, value) => Object.defineProperty(target, key, {
  value,
  writable: true,
  configurable: true
});
var numberRegex = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
var colorRegex = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi;
var unitRegex = new RegExp(`(${numberRegex.source})(%|[a-z]+)`, "i");
var rgbaRegex = /rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi;
var cssVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
var variableToRgba = (input) => {
  const [token, fallback] = parseCSSVariable(input);
  if (!token || isSSR()) {
    return input;
  }
  const value = window.getComputedStyle(document.documentElement).getPropertyValue(token);
  if (value) {
    return value.trim();
  } else if (fallback && fallback.startsWith("--")) {
    const value2 = window.getComputedStyle(document.documentElement).getPropertyValue(fallback);
    if (value2) {
      return value2;
    } else {
      return input;
    }
  } else if (fallback && cssVariableRegex.test(fallback)) {
    return variableToRgba(fallback);
  } else if (fallback) {
    return fallback;
  }
  return input;
};
var parseCSSVariable = (current) => {
  const match = cssVariableRegex.exec(current);
  if (!match) return [,];
  const [, token, fallback] = match;
  return [token, fallback];
};
var namedColorRegex;
var rgbaRound = (_2, p1, p22, p32, p4) => `rgba(${Math.round(p1)}, ${Math.round(p22)}, ${Math.round(p32)}, ${p4})`;
var createStringInterpolator2 = (config2) => {
  if (!namedColorRegex)
    namedColorRegex = colors ? (
      // match color names, ignore partial matches
      new RegExp(`(${Object.keys(colors).join("|")})(?!\\w)`, "g")
    ) : (
      // never match
      /^\b$/
    );
  const output = config2.output.map((value) => {
    return getFluidValue(value).replace(cssVariableRegex, variableToRgba).replace(colorRegex, colorToRgba).replace(namedColorRegex, colorToRgba);
  });
  const keyframes = output.map((value) => value.match(numberRegex).map(Number));
  const outputRanges = keyframes[0].map(
    (_2, i6) => keyframes.map((values) => {
      if (!(i6 in values)) {
        throw Error('The arity of each "output" value must be equal');
      }
      return values[i6];
    })
  );
  const interpolators = outputRanges.map(
    (output2) => createInterpolator({ ...config2, output: output2 })
  );
  return (input) => {
    var _a;
    const missingUnit = !unitRegex.test(output[0]) && ((_a = output.find((value) => unitRegex.test(value))) == null ? void 0 : _a.replace(numberRegex, ""));
    let i6 = 0;
    return output[0].replace(
      numberRegex,
      () => `${interpolators[i6++](input)}${missingUnit || ""}`
    ).replace(rgbaRegex, rgbaRound);
  };
};
var prefix = "react-spring: ";
var once = (fn3) => {
  const func = fn3;
  let called = false;
  if (typeof func != "function") {
    throw new TypeError(`${prefix}once requires a function parameter`);
  }
  return (...args) => {
    if (!called) {
      func(...args);
      called = true;
    }
  };
};
var warnInterpolate = once(console.warn);
function deprecateInterpolate() {
  warnInterpolate(
    `${prefix}The "interpolate" function is deprecated in v9 (use "to" instead)`
  );
}
var warnDirectCall = once(console.warn);
function deprecateDirectCall() {
  warnDirectCall(
    `${prefix}Directly calling start instead of using the api object is deprecated in v9 (use ".start" instead), this will be removed in later 0.X.0 versions`
  );
}
function isAnimatedString(value) {
  return is.str(value) && (value[0] == "#" || /\d/.test(value) || // Do not identify a CSS variable as an AnimatedString if its SSR
  !isSSR() && cssVariableRegex.test(value) || value in (colors || {}));
}
var useIsomorphicLayoutEffect = isSSR() ? import_react4.useEffect : import_react4.useLayoutEffect;
var useIsMounted = () => {
  const isMounted = (0, import_react3.useRef)(false);
  useIsomorphicLayoutEffect(() => {
    isMounted.current = true;
    return () => {
      isMounted.current = false;
    };
  }, []);
  return isMounted;
};
function useForceUpdate() {
  const update3 = (0, import_react2.useState)()[1];
  const isMounted = useIsMounted();
  return () => {
    if (isMounted.current) {
      update3(Math.random());
    }
  };
}
var useOnce = (effect) => (0, import_react6.useEffect)(effect, emptyDeps);
var emptyDeps = [];
function usePrev(value) {
  const prevRef = (0, import_react7.useRef)(void 0);
  (0, import_react7.useEffect)(() => {
    prevRef.current = value;
  });
  return prevRef.current;
}

// node_modules/@react-spring/core/dist/react-spring_core.modern.mjs
var import_react10 = __toESM(require_react(), 1);

// node_modules/@react-spring/animated/dist/react-spring_animated.modern.mjs
var React = __toESM(require_react(), 1);
var import_react9 = __toESM(require_react(), 1);
var $node = Symbol.for("Animated:node");
var isAnimated = (value) => !!value && value[$node] === value;
var getAnimated = (owner) => owner && owner[$node];
var setAnimated = (owner, node) => defineHidden(owner, $node, node);
var getPayload = (owner) => owner && owner[$node] && owner[$node].getPayload();
var Animated = class {
  constructor() {
    setAnimated(this, this);
  }
  /** Get every `AnimatedValue` used by this node. */
  getPayload() {
    return this.payload || [];
  }
};
var AnimatedValue = class _AnimatedValue extends Animated {
  constructor(_value) {
    super();
    this._value = _value;
    this.done = true;
    this.durationProgress = 0;
    if (is.num(this._value)) {
      this.lastPosition = this._value;
    }
  }
  /** @internal */
  static create(value) {
    return new _AnimatedValue(value);
  }
  getPayload() {
    return [this];
  }
  getValue() {
    return this._value;
  }
  setValue(value, step) {
    if (is.num(value)) {
      this.lastPosition = value;
      if (step) {
        value = Math.round(value / step) * step;
        if (this.done) {
          this.lastPosition = value;
        }
      }
    }
    if (this._value === value) {
      return false;
    }
    this._value = value;
    return true;
  }
  reset() {
    const { done } = this;
    this.done = false;
    if (is.num(this._value)) {
      this.elapsedTime = 0;
      this.durationProgress = 0;
      this.lastPosition = this._value;
      if (done) this.lastVelocity = null;
      this.v0 = null;
    }
  }
};
var AnimatedString = class _AnimatedString extends AnimatedValue {
  constructor(value) {
    super(0);
    this._string = null;
    this._toString = createInterpolator({
      output: [value, value]
    });
  }
  /** @internal */
  static create(value) {
    return new _AnimatedString(value);
  }
  getValue() {
    const value = this._string;
    return value == null ? this._string = this._toString(this._value) : value;
  }
  setValue(value) {
    if (is.str(value)) {
      if (value == this._string) {
        return false;
      }
      this._string = value;
      this._value = 1;
    } else if (super.setValue(value)) {
      this._string = null;
    } else {
      return false;
    }
    return true;
  }
  reset(goal) {
    if (goal) {
      this._toString = createInterpolator({
        output: [this.getValue(), goal]
      });
    }
    this._value = 0;
    super.reset();
  }
};
var TreeContext = { dependencies: null };
var AnimatedObject = class extends Animated {
  constructor(source) {
    super();
    this.source = source;
    this.setValue(source);
  }
  getValue(animated2) {
    const values = {};
    eachProp(this.source, (source, key) => {
      if (isAnimated(source)) {
        values[key] = source.getValue(animated2);
      } else if (hasFluidValue(source)) {
        values[key] = getFluidValue(source);
      } else if (!animated2) {
        values[key] = source;
      }
    });
    return values;
  }
  /** Replace the raw object data */
  setValue(source) {
    this.source = source;
    this.payload = this._makePayload(source);
  }
  reset() {
    if (this.payload) {
      each(this.payload, (node) => node.reset());
    }
  }
  /** Create a payload set. */
  _makePayload(source) {
    if (source) {
      const payload = /* @__PURE__ */ new Set();
      eachProp(source, this._addToPayload, payload);
      return Array.from(payload);
    }
  }
  /** Add to a payload set. */
  _addToPayload(source) {
    if (TreeContext.dependencies && hasFluidValue(source)) {
      TreeContext.dependencies.add(source);
    }
    const payload = getPayload(source);
    if (payload) {
      each(payload, (node) => this.add(node));
    }
  }
};
var AnimatedArray = class _AnimatedArray extends AnimatedObject {
  constructor(source) {
    super(source);
  }
  /** @internal */
  static create(source) {
    return new _AnimatedArray(source);
  }
  getValue() {
    return this.source.map((node) => node.getValue());
  }
  setValue(source) {
    const payload = this.getPayload();
    if (source.length == payload.length) {
      return payload.map((node, i6) => node.setValue(source[i6])).some(Boolean);
    }
    super.setValue(source.map(makeAnimated));
    return true;
  }
};
function makeAnimated(value) {
  const nodeType = isAnimatedString(value) ? AnimatedString : AnimatedValue;
  return nodeType.create(value);
}
function getAnimatedType(value) {
  const parentNode = getAnimated(value);
  return parentNode ? parentNode.constructor : is.arr(value) ? AnimatedArray : isAnimatedString(value) ? AnimatedString : AnimatedValue;
}
var withAnimated = (Component2, host2) => {
  const hasInstance = (
    // Function components must use "forwardRef" to avoid being
    // re-rendered on every animation frame.
    !is.fun(Component2) || Component2.prototype && Component2.prototype.isReactComponent
  );
  return (0, import_react9.forwardRef)((givenProps, givenRef) => {
    const instanceRef = (0, import_react9.useRef)(null);
    const ref = hasInstance && // eslint-disable-next-line react-hooks/rules-of-hooks
    (0, import_react9.useCallback)(
      (value) => {
        instanceRef.current = updateRef(givenRef, value);
      },
      [givenRef]
    );
    const [props, deps] = getAnimatedState(givenProps, host2);
    const forceUpdate = useForceUpdate();
    const callback = () => {
      const instance = instanceRef.current;
      if (hasInstance && !instance) {
        return;
      }
      const didUpdate = instance ? host2.applyAnimatedValues(instance, props.getValue(true)) : false;
      if (didUpdate === false) {
        forceUpdate();
      }
    };
    const observer = new PropsObserver(callback, deps);
    const observerRef = (0, import_react9.useRef)(void 0);
    useIsomorphicLayoutEffect(() => {
      observerRef.current = observer;
      each(deps, (dep) => addFluidObserver(dep, observer));
      return () => {
        if (observerRef.current) {
          each(
            observerRef.current.deps,
            (dep) => removeFluidObserver(dep, observerRef.current)
          );
          raf.cancel(observerRef.current.update);
        }
      };
    });
    (0, import_react9.useEffect)(callback, []);
    useOnce(() => () => {
      const observer2 = observerRef.current;
      each(observer2.deps, (dep) => removeFluidObserver(dep, observer2));
    });
    const usedProps = host2.getComponentProps(props.getValue());
    return React.createElement(Component2, { ...usedProps, ref });
  });
};
var PropsObserver = class {
  constructor(update3, deps) {
    this.update = update3;
    this.deps = deps;
  }
  eventObserved(event) {
    if (event.type == "change") {
      raf.write(this.update);
    }
  }
};
function getAnimatedState(props, host2) {
  const dependencies = /* @__PURE__ */ new Set();
  TreeContext.dependencies = dependencies;
  if (props.style)
    props = {
      ...props,
      style: host2.createAnimatedStyle(props.style)
    };
  props = new AnimatedObject(props);
  TreeContext.dependencies = null;
  return [props, dependencies];
}
function updateRef(ref, value) {
  if (ref) {
    if (is.fun(ref)) ref(value);
    else ref.current = value;
  }
  return value;
}
var cacheKey = Symbol.for("AnimatedComponent");
var createHost = (components, {
  applyAnimatedValues: applyAnimatedValues2 = () => false,
  createAnimatedStyle = (style) => new AnimatedObject(style),
  getComponentProps = (props) => props
} = {}) => {
  const hostConfig = {
    applyAnimatedValues: applyAnimatedValues2,
    createAnimatedStyle,
    getComponentProps
  };
  const animated2 = (Component2) => {
    const displayName = getDisplayName(Component2) || "Anonymous";
    if (is.str(Component2)) {
      Component2 = animated2[Component2] || (animated2[Component2] = withAnimated(Component2, hostConfig));
    } else {
      Component2 = Component2[cacheKey] || (Component2[cacheKey] = withAnimated(Component2, hostConfig));
    }
    Component2.displayName = `Animated(${displayName})`;
    return Component2;
  };
  eachProp(components, (Component2, key) => {
    if (is.arr(components)) {
      key = getDisplayName(Component2);
    }
    animated2[key] = animated2(Component2);
  });
  return {
    animated: animated2
  };
};
var getDisplayName = (arg) => is.str(arg) ? arg : arg && is.str(arg.displayName) ? arg.displayName : is.fun(arg) && arg.name || null;

// node_modules/@react-spring/core/dist/react-spring_core.modern.mjs
var React2 = __toESM(require_react(), 1);
var import_react11 = __toESM(require_react(), 1);
var import_react12 = __toESM(require_react(), 1);
var React22 = __toESM(require_react(), 1);
var import_react13 = __toESM(require_react(), 1);
var import_react14 = __toESM(require_react(), 1);
function callProp(value, ...args) {
  return is.fun(value) ? value(...args) : value;
}
var matchProp = (value, key) => value === true || !!(key && value && (is.fun(value) ? value(key) : toArray(value).includes(key)));
var resolveProp = (prop, key) => is.obj(prop) ? key && prop[key] : prop;
var getDefaultProp = (props, key) => props.default === true ? props[key] : props.default ? props.default[key] : void 0;
var noopTransform = (value) => value;
var getDefaultProps = (props, transform = noopTransform) => {
  let keys = DEFAULT_PROPS;
  if (props.default && props.default !== true) {
    props = props.default;
    keys = Object.keys(props);
  }
  const defaults2 = {};
  for (const key of keys) {
    const value = transform(props[key], key);
    if (!is.und(value)) {
      defaults2[key] = value;
    }
  }
  return defaults2;
};
var DEFAULT_PROPS = [
  "config",
  "onProps",
  "onStart",
  "onChange",
  "onPause",
  "onResume",
  "onRest"
];
var RESERVED_PROPS = {
  config: 1,
  from: 1,
  to: 1,
  ref: 1,
  loop: 1,
  reset: 1,
  pause: 1,
  cancel: 1,
  reverse: 1,
  immediate: 1,
  default: 1,
  delay: 1,
  onProps: 1,
  onStart: 1,
  onChange: 1,
  onPause: 1,
  onResume: 1,
  onRest: 1,
  onResolve: 1,
  // Transition props
  items: 1,
  trail: 1,
  sort: 1,
  expires: 1,
  initial: 1,
  enter: 1,
  update: 1,
  leave: 1,
  children: 1,
  onDestroyed: 1,
  // Internal props
  keys: 1,
  callId: 1,
  parentId: 1
};
function getForwardProps(props) {
  const forward = {};
  let count2 = 0;
  eachProp(props, (value, prop) => {
    if (!RESERVED_PROPS[prop]) {
      forward[prop] = value;
      count2++;
    }
  });
  if (count2) {
    return forward;
  }
}
function inferTo(props) {
  const to22 = getForwardProps(props);
  if (to22) {
    const out = { to: to22 };
    eachProp(props, (val, key) => key in to22 || (out[key] = val));
    return out;
  }
  return { ...props };
}
function computeGoal(value) {
  value = getFluidValue(value);
  return is.arr(value) ? value.map(computeGoal) : isAnimatedString(value) ? globals_exports.createStringInterpolator({
    range: [0, 1],
    output: [value, value]
  })(1) : value;
}
function hasProps(props) {
  for (const _2 in props) return true;
  return false;
}
function isAsyncTo(to22) {
  return is.fun(to22) || is.arr(to22) && is.obj(to22[0]);
}
function detachRefs(ctrl, ref) {
  var _a;
  (_a = ctrl.ref) == null ? void 0 : _a.delete(ctrl);
  ref == null ? void 0 : ref.delete(ctrl);
}
function replaceRef(ctrl, ref) {
  var _a;
  if (ref && ctrl.ref !== ref) {
    (_a = ctrl.ref) == null ? void 0 : _a.delete(ctrl);
    ref.add(ctrl);
    ctrl.ref = ref;
  }
}
var config = {
  default: { tension: 170, friction: 26 },
  gentle: { tension: 120, friction: 14 },
  wobbly: { tension: 180, friction: 12 },
  stiff: { tension: 210, friction: 20 },
  slow: { tension: 280, friction: 60 },
  molasses: { tension: 280, friction: 120 }
};
var defaults = {
  ...config.default,
  mass: 1,
  damping: 1,
  easing: easings.linear,
  clamp: false
};
var AnimationConfig = class {
  constructor() {
    this.velocity = 0;
    Object.assign(this, defaults);
  }
};
function mergeConfig(config2, newConfig, defaultConfig) {
  if (defaultConfig) {
    defaultConfig = { ...defaultConfig };
    sanitizeConfig(defaultConfig, newConfig);
    newConfig = { ...defaultConfig, ...newConfig };
  }
  sanitizeConfig(config2, newConfig);
  Object.assign(config2, newConfig);
  for (const key in defaults) {
    if (config2[key] == null) {
      config2[key] = defaults[key];
    }
  }
  let { frequency, damping } = config2;
  const { mass } = config2;
  if (!is.und(frequency)) {
    if (frequency < 0.01) frequency = 0.01;
    if (damping < 0) damping = 0;
    config2.tension = Math.pow(2 * Math.PI / frequency, 2) * mass;
    config2.friction = 4 * Math.PI * damping * mass / frequency;
  }
  return config2;
}
function sanitizeConfig(config2, props) {
  if (!is.und(props.decay)) {
    config2.duration = void 0;
  } else {
    const isTensionConfig = !is.und(props.tension) || !is.und(props.friction);
    if (isTensionConfig || !is.und(props.frequency) || !is.und(props.damping) || !is.und(props.mass)) {
      config2.duration = void 0;
      config2.decay = void 0;
    }
    if (isTensionConfig) {
      config2.frequency = void 0;
    }
  }
}
var emptyArray = [];
var Animation = class {
  constructor() {
    this.changed = false;
    this.values = emptyArray;
    this.toValues = null;
    this.fromValues = emptyArray;
    this.config = new AnimationConfig();
    this.immediate = false;
  }
};
function scheduleProps(callId, { key, props, defaultProps, state, actions }) {
  return new Promise((resolve, reject) => {
    let delay;
    let timeout;
    let cancel = matchProp(props.cancel ?? (defaultProps == null ? void 0 : defaultProps.cancel), key);
    if (cancel) {
      onStart();
    } else {
      if (!is.und(props.pause)) {
        state.paused = matchProp(props.pause, key);
      }
      let pause = defaultProps == null ? void 0 : defaultProps.pause;
      if (pause !== true) {
        pause = state.paused || matchProp(pause, key);
      }
      delay = callProp(props.delay || 0, key);
      if (pause) {
        state.resumeQueue.add(onResume);
        actions.pause();
      } else {
        actions.resume();
        onResume();
      }
    }
    function onPause() {
      state.resumeQueue.add(onResume);
      state.timeouts.delete(timeout);
      timeout.cancel();
      delay = timeout.time - raf.now();
    }
    function onResume() {
      if (delay > 0 && !globals_exports.skipAnimation) {
        state.delayed = true;
        timeout = raf.setTimeout(onStart, delay);
        state.pauseQueue.add(onPause);
        state.timeouts.add(timeout);
      } else {
        onStart();
      }
    }
    function onStart() {
      if (state.delayed) {
        state.delayed = false;
      }
      state.pauseQueue.delete(onPause);
      state.timeouts.delete(timeout);
      if (callId <= (state.cancelId || 0)) {
        cancel = true;
      }
      try {
        actions.start({ ...props, callId, cancel }, resolve);
      } catch (err) {
        reject(err);
      }
    }
  });
}
var getCombinedResult = (target, results) => results.length == 1 ? results[0] : results.some((result) => result.cancelled) ? getCancelledResult(target.get()) : results.every((result) => result.noop) ? getNoopResult(target.get()) : getFinishedResult(
  target.get(),
  results.every((result) => result.finished)
);
var getNoopResult = (value) => ({
  value,
  noop: true,
  finished: true,
  cancelled: false
});
var getFinishedResult = (value, finished, cancelled = false) => ({
  value,
  finished,
  cancelled
});
var getCancelledResult = (value) => ({
  value,
  cancelled: true,
  finished: false
});
function runAsync(to22, props, state, target) {
  const { callId, parentId, onRest } = props;
  const { asyncTo: prevTo, promise: prevPromise } = state;
  if (!parentId && to22 === prevTo && !props.reset) {
    return prevPromise;
  }
  return state.promise = (async () => {
    state.asyncId = callId;
    state.asyncTo = to22;
    const defaultProps = getDefaultProps(
      props,
      (value, key) => (
        // The `onRest` prop is only called when the `runAsync` promise is resolved.
        key === "onRest" ? void 0 : value
      )
    );
    let preventBail;
    let bail;
    const bailPromise = new Promise(
      (resolve, reject) => (preventBail = resolve, bail = reject)
    );
    const bailIfEnded = (bailSignal) => {
      const bailResult = (
        // The `cancel` prop or `stop` method was used.
        callId <= (state.cancelId || 0) && getCancelledResult(target) || // The async `to` prop was replaced.
        callId !== state.asyncId && getFinishedResult(target, false)
      );
      if (bailResult) {
        bailSignal.result = bailResult;
        bail(bailSignal);
        throw bailSignal;
      }
    };
    const animate = (arg1, arg2) => {
      const bailSignal = new BailSignal();
      const skipAnimationSignal = new SkipAnimationSignal();
      return (async () => {
        if (globals_exports.skipAnimation) {
          stopAsync(state);
          skipAnimationSignal.result = getFinishedResult(target, false);
          bail(skipAnimationSignal);
          throw skipAnimationSignal;
        }
        bailIfEnded(bailSignal);
        const props2 = is.obj(arg1) ? { ...arg1 } : { ...arg2, to: arg1 };
        props2.parentId = callId;
        eachProp(defaultProps, (value, key) => {
          if (is.und(props2[key])) {
            props2[key] = value;
          }
        });
        const result2 = await target.start(props2);
        bailIfEnded(bailSignal);
        if (state.paused) {
          await new Promise((resume) => {
            state.resumeQueue.add(resume);
          });
        }
        return result2;
      })();
    };
    let result;
    if (globals_exports.skipAnimation) {
      stopAsync(state);
      return getFinishedResult(target, false);
    }
    try {
      let animating;
      if (is.arr(to22)) {
        animating = (async (queue) => {
          for (const props2 of queue) {
            await animate(props2);
          }
        })(to22);
      } else {
        animating = Promise.resolve(to22(animate, target.stop.bind(target)));
      }
      await Promise.all([animating.then(preventBail), bailPromise]);
      result = getFinishedResult(target.get(), true, false);
    } catch (err) {
      if (err instanceof BailSignal) {
        result = err.result;
      } else if (err instanceof SkipAnimationSignal) {
        result = err.result;
      } else {
        throw err;
      }
    } finally {
      if (callId == state.asyncId) {
        state.asyncId = parentId;
        state.asyncTo = parentId ? prevTo : void 0;
        state.promise = parentId ? prevPromise : void 0;
      }
    }
    if (is.fun(onRest)) {
      raf.batchedUpdates(() => {
        onRest(result, target, target.item);
      });
    }
    return result;
  })();
}
function stopAsync(state, cancelId) {
  flush(state.timeouts, (t5) => t5.cancel());
  state.pauseQueue.clear();
  state.resumeQueue.clear();
  state.asyncId = state.asyncTo = state.promise = void 0;
  if (cancelId) state.cancelId = cancelId;
}
var BailSignal = class extends Error {
  constructor() {
    super(
      "An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise."
    );
  }
};
var SkipAnimationSignal = class extends Error {
  constructor() {
    super("SkipAnimationSignal");
  }
};
var isFrameValue = (value) => value instanceof FrameValue;
var nextId = 1;
var FrameValue = class extends FluidValue {
  constructor() {
    super(...arguments);
    this.id = nextId++;
    this._priority = 0;
  }
  get priority() {
    return this._priority;
  }
  set priority(priority2) {
    if (this._priority != priority2) {
      this._priority = priority2;
      this._onPriorityChange(priority2);
    }
  }
  /** Get the current value */
  get() {
    const node = getAnimated(this);
    return node && node.getValue();
  }
  /** Create a spring that maps our value to another value */
  to(...args) {
    return globals_exports.to(this, args);
  }
  /** @deprecated Use the `to` method instead. */
  interpolate(...args) {
    deprecateInterpolate();
    return globals_exports.to(this, args);
  }
  toJSON() {
    return this.get();
  }
  observerAdded(count2) {
    if (count2 == 1) this._attach();
  }
  observerRemoved(count2) {
    if (count2 == 0) this._detach();
  }
  /** Called when the first child is added. */
  _attach() {
  }
  /** Called when the last child is removed. */
  _detach() {
  }
  /** Tell our children about our new value */
  _onChange(value, idle = false) {
    callFluidObservers(this, {
      type: "change",
      parent: this,
      value,
      idle
    });
  }
  /** Tell our children about our new priority */
  _onPriorityChange(priority2) {
    if (!this.idle) {
      frameLoop.sort(this);
    }
    callFluidObservers(this, {
      type: "priority",
      parent: this,
      priority: priority2
    });
  }
};
var $P = Symbol.for("SpringPhase");
var HAS_ANIMATED = 1;
var IS_ANIMATING = 2;
var IS_PAUSED = 4;
var hasAnimated = (target) => (target[$P] & HAS_ANIMATED) > 0;
var isAnimating = (target) => (target[$P] & IS_ANIMATING) > 0;
var isPaused = (target) => (target[$P] & IS_PAUSED) > 0;
var setActiveBit = (target, active) => active ? target[$P] |= IS_ANIMATING | HAS_ANIMATED : target[$P] &= ~IS_ANIMATING;
var setPausedBit = (target, paused) => paused ? target[$P] |= IS_PAUSED : target[$P] &= ~IS_PAUSED;
var SpringValue = class extends FrameValue {
  constructor(arg1, arg2) {
    super();
    this.animation = new Animation();
    this.defaultProps = {};
    this._state = {
      paused: false,
      delayed: false,
      pauseQueue: /* @__PURE__ */ new Set(),
      resumeQueue: /* @__PURE__ */ new Set(),
      timeouts: /* @__PURE__ */ new Set()
    };
    this._pendingCalls = /* @__PURE__ */ new Set();
    this._lastCallId = 0;
    this._lastToId = 0;
    this._memoizedDuration = 0;
    if (!is.und(arg1) || !is.und(arg2)) {
      const props = is.obj(arg1) ? { ...arg1 } : { ...arg2, from: arg1 };
      if (is.und(props.default)) {
        props.default = true;
      }
      this.start(props);
    }
  }
  /** Equals true when not advancing on each frame. */
  get idle() {
    return !(isAnimating(this) || this._state.asyncTo) || isPaused(this);
  }
  get goal() {
    return getFluidValue(this.animation.to);
  }
  get velocity() {
    const node = getAnimated(this);
    return node instanceof AnimatedValue ? node.lastVelocity || 0 : node.getPayload().map((node2) => node2.lastVelocity || 0);
  }
  /**
   * When true, this value has been animated at least once.
   */
  get hasAnimated() {
    return hasAnimated(this);
  }
  /**
   * When true, this value has an unfinished animation,
   * which is either active or paused.
   */
  get isAnimating() {
    return isAnimating(this);
  }
  /**
   * When true, all current and future animations are paused.
   */
  get isPaused() {
    return isPaused(this);
  }
  /**
   *
   *
   */
  get isDelayed() {
    return this._state.delayed;
  }
  /** Advance the current animation by a number of milliseconds */
  advance(dt2) {
    let idle = true;
    let changed = false;
    const anim = this.animation;
    let { toValues } = anim;
    const { config: config2 } = anim;
    const payload = getPayload(anim.to);
    if (!payload && hasFluidValue(anim.to)) {
      toValues = toArray(getFluidValue(anim.to));
    }
    anim.values.forEach((node2, i6) => {
      if (node2.done) return;
      const to22 = (
        // Animated strings always go from 0 to 1.
        node2.constructor == AnimatedString ? 1 : payload ? payload[i6].lastPosition : toValues[i6]
      );
      let finished = anim.immediate;
      let position = to22;
      if (!finished) {
        position = node2.lastPosition;
        if (config2.tension <= 0) {
          node2.done = true;
          return;
        }
        let elapsed = node2.elapsedTime += dt2;
        const from = anim.fromValues[i6];
        const v0 = node2.v0 != null ? node2.v0 : node2.v0 = is.arr(config2.velocity) ? config2.velocity[i6] : config2.velocity;
        let velocity;
        const precision = config2.precision || (from == to22 ? 5e-3 : Math.min(1, Math.abs(to22 - from) * 1e-3));
        if (!is.und(config2.duration)) {
          let p4 = 1;
          if (config2.duration > 0) {
            if (this._memoizedDuration !== config2.duration) {
              this._memoizedDuration = config2.duration;
              if (node2.durationProgress > 0) {
                node2.elapsedTime = config2.duration * node2.durationProgress;
                elapsed = node2.elapsedTime += dt2;
              }
            }
            p4 = (config2.progress || 0) + elapsed / this._memoizedDuration;
            p4 = p4 > 1 ? 1 : p4 < 0 ? 0 : p4;
            node2.durationProgress = p4;
          }
          position = from + config2.easing(p4) * (to22 - from);
          velocity = (position - node2.lastPosition) / dt2;
          finished = p4 == 1;
        } else if (config2.decay) {
          const decay = config2.decay === true ? 0.998 : config2.decay;
          const e8 = Math.exp(-(1 - decay) * elapsed);
          position = from + v0 / (1 - decay) * (1 - e8);
          finished = Math.abs(node2.lastPosition - position) <= precision;
          velocity = v0 * e8;
        } else {
          velocity = node2.lastVelocity == null ? v0 : node2.lastVelocity;
          const restVelocity = config2.restVelocity || precision / 10;
          const bounceFactor = config2.clamp ? 0 : config2.bounce;
          const canBounce = !is.und(bounceFactor);
          const isGrowing = from == to22 ? node2.v0 > 0 : from < to22;
          let isMoving;
          let isBouncing = false;
          const step = 1;
          const numSteps = Math.ceil(dt2 / step);
          for (let n6 = 0; n6 < numSteps; ++n6) {
            isMoving = Math.abs(velocity) > restVelocity;
            if (!isMoving) {
              finished = Math.abs(to22 - position) <= precision;
              if (finished) {
                break;
              }
            }
            if (canBounce) {
              isBouncing = position == to22 || position > to22 == isGrowing;
              if (isBouncing) {
                velocity = -velocity * bounceFactor;
                position = to22;
              }
            }
            const springForce = -config2.tension * 1e-6 * (position - to22);
            const dampingForce = -config2.friction * 1e-3 * velocity;
            const acceleration = (springForce + dampingForce) / config2.mass;
            velocity = velocity + acceleration * step;
            position = position + velocity * step;
          }
        }
        node2.lastVelocity = velocity;
        if (Number.isNaN(position)) {
          console.warn(`Got NaN while animating:`, this);
          finished = true;
        }
      }
      if (payload && !payload[i6].done) {
        finished = false;
      }
      if (finished) {
        node2.done = true;
      } else {
        idle = false;
      }
      if (node2.setValue(position, config2.round)) {
        changed = true;
      }
    });
    const node = getAnimated(this);
    const currVal = node.getValue();
    if (idle) {
      const finalVal = getFluidValue(anim.to);
      if ((currVal !== finalVal || changed) && !config2.decay) {
        node.setValue(finalVal);
        this._onChange(finalVal);
      } else if (changed && config2.decay) {
        this._onChange(currVal);
      }
      this._stop();
    } else if (changed) {
      this._onChange(currVal);
    }
  }
  /** Set the current value, while stopping the current animation */
  set(value) {
    raf.batchedUpdates(() => {
      this._stop();
      this._focus(value);
      this._set(value);
    });
    return this;
  }
  /**
   * Freeze the active animation in time, as well as any updates merged
   * before `resume` is called.
   */
  pause() {
    this._update({ pause: true });
  }
  /** Resume the animation if paused. */
  resume() {
    this._update({ pause: false });
  }
  /** Skip to the end of the current animation. */
  finish() {
    if (isAnimating(this)) {
      const { to: to22, config: config2 } = this.animation;
      raf.batchedUpdates(() => {
        this._onStart();
        if (!config2.decay) {
          this._set(to22, false);
        }
        this._stop();
      });
    }
    return this;
  }
  /** Push props into the pending queue. */
  update(props) {
    const queue = this.queue || (this.queue = []);
    queue.push(props);
    return this;
  }
  start(to22, arg2) {
    let queue;
    if (!is.und(to22)) {
      queue = [is.obj(to22) ? to22 : { ...arg2, to: to22 }];
    } else {
      queue = this.queue || [];
      this.queue = [];
    }
    return Promise.all(
      queue.map((props) => {
        const up = this._update(props);
        return up;
      })
    ).then((results) => getCombinedResult(this, results));
  }
  /**
   * Stop the current animation, and cancel any delayed updates.
   *
   * Pass `true` to call `onRest` with `cancelled: true`.
   */
  stop(cancel) {
    const { to: to22 } = this.animation;
    this._focus(this.get());
    stopAsync(this._state, cancel && this._lastCallId);
    raf.batchedUpdates(() => this._stop(to22, cancel));
    return this;
  }
  /** Restart the animation. */
  reset() {
    this._update({ reset: true });
  }
  /** @internal */
  eventObserved(event) {
    if (event.type == "change") {
      this._start();
    } else if (event.type == "priority") {
      this.priority = event.priority + 1;
    }
  }
  /**
   * Parse the `to` and `from` range from the given `props` object.
   *
   * This also ensures the initial value is available to animated components
   * during the render phase.
   */
  _prepareNode(props) {
    const key = this.key || "";
    let { to: to22, from } = props;
    to22 = is.obj(to22) ? to22[key] : to22;
    if (to22 == null || isAsyncTo(to22)) {
      to22 = void 0;
    }
    from = is.obj(from) ? from[key] : from;
    if (from == null) {
      from = void 0;
    }
    const range = { to: to22, from };
    if (!hasAnimated(this)) {
      if (props.reverse) [to22, from] = [from, to22];
      from = getFluidValue(from);
      if (!is.und(from)) {
        this._set(from);
      } else if (!getAnimated(this)) {
        this._set(to22);
      }
    }
    return range;
  }
  /** Every update is processed by this method before merging. */
  _update({ ...props }, isLoop) {
    const { key, defaultProps } = this;
    if (props.default)
      Object.assign(
        defaultProps,
        getDefaultProps(
          props,
          (value, prop) => /^on/.test(prop) ? resolveProp(value, key) : value
        )
      );
    mergeActiveFn(this, props, "onProps");
    sendEvent(this, "onProps", props, this);
    const range = this._prepareNode(props);
    if (Object.isFrozen(this)) {
      throw Error(
        "Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?"
      );
    }
    const state = this._state;
    return scheduleProps(++this._lastCallId, {
      key,
      props,
      defaultProps,
      state,
      actions: {
        pause: () => {
          if (!isPaused(this)) {
            setPausedBit(this, true);
            flushCalls(state.pauseQueue);
            sendEvent(
              this,
              "onPause",
              getFinishedResult(this, checkFinished(this, this.animation.to)),
              this
            );
          }
        },
        resume: () => {
          if (isPaused(this)) {
            setPausedBit(this, false);
            if (isAnimating(this)) {
              this._resume();
            }
            flushCalls(state.resumeQueue);
            sendEvent(
              this,
              "onResume",
              getFinishedResult(this, checkFinished(this, this.animation.to)),
              this
            );
          }
        },
        start: this._merge.bind(this, range)
      }
    }).then((result) => {
      if (props.loop && result.finished && !(isLoop && result.noop)) {
        const nextProps = createLoopUpdate(props);
        if (nextProps) {
          return this._update(nextProps, true);
        }
      }
      return result;
    });
  }
  /** Merge props into the current animation */
  _merge(range, props, resolve) {
    if (props.cancel) {
      this.stop(true);
      return resolve(getCancelledResult(this));
    }
    const hasToProp = !is.und(range.to);
    const hasFromProp = !is.und(range.from);
    if (hasToProp || hasFromProp) {
      if (props.callId > this._lastToId) {
        this._lastToId = props.callId;
      } else {
        return resolve(getCancelledResult(this));
      }
    }
    const { key, defaultProps, animation: anim } = this;
    const { to: prevTo, from: prevFrom } = anim;
    let { to: to22 = prevTo, from = prevFrom } = range;
    if (hasFromProp && !hasToProp && (!props.default || is.und(to22))) {
      to22 = from;
    }
    if (props.reverse) [to22, from] = [from, to22];
    const hasFromChanged = !isEqual(from, prevFrom);
    if (hasFromChanged) {
      anim.from = from;
    }
    from = getFluidValue(from);
    const hasToChanged = !isEqual(to22, prevTo);
    if (hasToChanged) {
      this._focus(to22);
    }
    const hasAsyncTo = isAsyncTo(props.to);
    const { config: config2 } = anim;
    const { decay, velocity } = config2;
    if (hasToProp || hasFromProp) {
      config2.velocity = 0;
    }
    if (props.config && !hasAsyncTo) {
      mergeConfig(
        config2,
        callProp(props.config, key),
        // Avoid calling the same "config" prop twice.
        props.config !== defaultProps.config ? callProp(defaultProps.config, key) : void 0
      );
    }
    let node = getAnimated(this);
    if (!node || is.und(to22)) {
      return resolve(getFinishedResult(this, true));
    }
    const reset = (
      // When `reset` is undefined, the `from` prop implies `reset: true`,
      // except for declarative updates. When `reset` is defined, there
      // must exist a value to animate from.
      is.und(props.reset) ? hasFromProp && !props.default : !is.und(from) && matchProp(props.reset, key)
    );
    const value = reset ? from : this.get();
    const goal = computeGoal(to22);
    const isAnimatable = is.num(goal) || is.arr(goal) || isAnimatedString(goal);
    const immediate = !hasAsyncTo && (!isAnimatable || matchProp(defaultProps.immediate || props.immediate, key));
    if (hasToChanged) {
      const nodeType = getAnimatedType(to22);
      if (nodeType !== node.constructor) {
        if (immediate) {
          node = this._set(goal);
        } else
          throw Error(
            `Cannot animate between ${node.constructor.name} and ${nodeType.name}, as the "to" prop suggests`
          );
      }
    }
    const goalType = node.constructor;
    let started = hasFluidValue(to22);
    let finished = false;
    if (!started) {
      const hasValueChanged = reset || !hasAnimated(this) && hasFromChanged;
      if (hasToChanged || hasValueChanged) {
        finished = isEqual(computeGoal(value), goal);
        started = !finished;
      }
      if (!isEqual(anim.immediate, immediate) && !immediate || !isEqual(config2.decay, decay) || !isEqual(config2.velocity, velocity)) {
        started = true;
      }
    }
    if (finished && isAnimating(this)) {
      if (anim.changed && !reset) {
        started = true;
      } else if (!started) {
        this._stop(prevTo);
      }
    }
    if (!hasAsyncTo) {
      if (started || hasFluidValue(prevTo)) {
        anim.values = node.getPayload();
        anim.toValues = hasFluidValue(to22) ? null : goalType == AnimatedString ? [1] : toArray(goal);
      }
      if (anim.immediate != immediate) {
        anim.immediate = immediate;
        if (!immediate && !reset) {
          this._set(prevTo);
        }
      }
      if (started) {
        const { onRest } = anim;
        each(ACTIVE_EVENTS, (type) => mergeActiveFn(this, props, type));
        const result = getFinishedResult(this, checkFinished(this, prevTo));
        flushCalls(this._pendingCalls, result);
        this._pendingCalls.add(resolve);
        if (anim.changed)
          raf.batchedUpdates(() => {
            var _a;
            anim.changed = !reset;
            onRest == null ? void 0 : onRest(result, this);
            if (reset) {
              callProp(defaultProps.onRest, result);
            } else {
              (_a = anim.onStart) == null ? void 0 : _a.call(anim, result, this);
            }
          });
      }
    }
    if (reset) {
      this._set(value);
    }
    if (hasAsyncTo) {
      resolve(runAsync(props.to, props, this._state, this));
    } else if (started) {
      this._start();
    } else if (isAnimating(this) && !hasToChanged) {
      this._pendingCalls.add(resolve);
    } else {
      resolve(getNoopResult(value));
    }
  }
  /** Update the `animation.to` value, which might be a `FluidValue` */
  _focus(value) {
    const anim = this.animation;
    if (value !== anim.to) {
      if (getFluidObservers(this)) {
        this._detach();
      }
      anim.to = value;
      if (getFluidObservers(this)) {
        this._attach();
      }
    }
  }
  _attach() {
    let priority2 = 0;
    const { to: to22 } = this.animation;
    if (hasFluidValue(to22)) {
      addFluidObserver(to22, this);
      if (isFrameValue(to22)) {
        priority2 = to22.priority + 1;
      }
    }
    this.priority = priority2;
  }
  _detach() {
    const { to: to22 } = this.animation;
    if (hasFluidValue(to22)) {
      removeFluidObserver(to22, this);
    }
  }
  /**
   * Update the current value from outside the frameloop,
   * and return the `Animated` node.
   */
  _set(arg, idle = true) {
    const value = getFluidValue(arg);
    if (!is.und(value)) {
      const oldNode = getAnimated(this);
      if (!oldNode || !isEqual(value, oldNode.getValue())) {
        const nodeType = getAnimatedType(value);
        if (!oldNode || oldNode.constructor != nodeType) {
          setAnimated(this, nodeType.create(value));
        } else {
          oldNode.setValue(value);
        }
        if (oldNode) {
          raf.batchedUpdates(() => {
            this._onChange(value, idle);
          });
        }
      }
    }
    return getAnimated(this);
  }
  _onStart() {
    const anim = this.animation;
    if (!anim.changed) {
      anim.changed = true;
      sendEvent(
        this,
        "onStart",
        getFinishedResult(this, checkFinished(this, anim.to)),
        this
      );
    }
  }
  _onChange(value, idle) {
    if (!idle) {
      this._onStart();
      callProp(this.animation.onChange, value, this);
    }
    callProp(this.defaultProps.onChange, value, this);
    super._onChange(value, idle);
  }
  // This method resets the animation state (even if already animating) to
  // ensure the latest from/to range is used, and it also ensures this spring
  // is added to the frameloop.
  _start() {
    const anim = this.animation;
    getAnimated(this).reset(getFluidValue(anim.to));
    if (!anim.immediate) {
      anim.fromValues = anim.values.map((node) => node.lastPosition);
    }
    if (!isAnimating(this)) {
      setActiveBit(this, true);
      if (!isPaused(this)) {
        this._resume();
      }
    }
  }
  _resume() {
    if (globals_exports.skipAnimation) {
      this.finish();
    } else {
      frameLoop.start(this);
    }
  }
  /**
   * Exit the frameloop and notify `onRest` listeners.
   *
   * Always wrap `_stop` calls with `batchedUpdates`.
   */
  _stop(goal, cancel) {
    if (isAnimating(this)) {
      setActiveBit(this, false);
      const anim = this.animation;
      each(anim.values, (node) => {
        node.done = true;
      });
      if (anim.toValues) {
        anim.onChange = anim.onPause = anim.onResume = void 0;
      }
      callFluidObservers(this, {
        type: "idle",
        parent: this
      });
      const result = cancel ? getCancelledResult(this.get()) : getFinishedResult(this.get(), checkFinished(this, goal ?? anim.to));
      flushCalls(this._pendingCalls, result);
      if (anim.changed) {
        anim.changed = false;
        sendEvent(this, "onRest", result, this);
      }
    }
  }
};
function checkFinished(target, to22) {
  const goal = computeGoal(to22);
  const value = computeGoal(target.get());
  return isEqual(value, goal);
}
function createLoopUpdate(props, loop2 = props.loop, to22 = props.to) {
  const loopRet = callProp(loop2);
  if (loopRet) {
    const overrides = loopRet !== true && inferTo(loopRet);
    const reverse2 = (overrides || props).reverse;
    const reset = !overrides || overrides.reset;
    return createUpdate({
      ...props,
      loop: loop2,
      // Avoid updating default props when looping.
      default: false,
      // Never loop the `pause` prop.
      pause: void 0,
      // For the "reverse" prop to loop as expected, the "to" prop
      // must be undefined. The "reverse" prop is ignored when the
      // "to" prop is an array or function.
      to: !reverse2 || isAsyncTo(to22) ? to22 : void 0,
      // Ignore the "from" prop except on reset.
      from: reset ? props.from : void 0,
      reset,
      // The "loop" prop can return a "useSpring" props object to
      // override any of the original props.
      ...overrides
    });
  }
}
function createUpdate(props) {
  const { to: to22, from } = props = inferTo(props);
  const keys = /* @__PURE__ */ new Set();
  if (is.obj(to22)) findDefined(to22, keys);
  if (is.obj(from)) findDefined(from, keys);
  props.keys = keys.size ? Array.from(keys) : null;
  return props;
}
function declareUpdate(props) {
  const update22 = createUpdate(props);
  if (is.und(update22.default)) {
    update22.default = getDefaultProps(update22);
  }
  return update22;
}
function findDefined(values, keys) {
  eachProp(values, (value, key) => value != null && keys.add(key));
}
var ACTIVE_EVENTS = [
  "onStart",
  "onRest",
  "onChange",
  "onPause",
  "onResume"
];
function mergeActiveFn(target, props, type) {
  target.animation[type] = props[type] !== getDefaultProp(props, type) ? resolveProp(props[type], target.key) : void 0;
}
function sendEvent(target, type, ...args) {
  var _a, _b, _c, _d;
  (_b = (_a = target.animation)[type]) == null ? void 0 : _b.call(_a, ...args);
  (_d = (_c = target.defaultProps)[type]) == null ? void 0 : _d.call(_c, ...args);
}
var BATCHED_EVENTS = ["onStart", "onChange", "onRest"];
var nextId2 = 1;
var Controller = class {
  constructor(props, flush3) {
    this.id = nextId2++;
    this.springs = {};
    this.queue = [];
    this._lastAsyncId = 0;
    this._active = /* @__PURE__ */ new Set();
    this._changed = /* @__PURE__ */ new Set();
    this._started = false;
    this._state = {
      paused: false,
      pauseQueue: /* @__PURE__ */ new Set(),
      resumeQueue: /* @__PURE__ */ new Set(),
      timeouts: /* @__PURE__ */ new Set()
    };
    this._events = {
      onStart: /* @__PURE__ */ new Map(),
      onChange: /* @__PURE__ */ new Map(),
      onRest: /* @__PURE__ */ new Map()
    };
    this._onFrame = this._onFrame.bind(this);
    if (flush3) {
      this._flush = flush3;
    }
    if (props) {
      this.start({ default: true, ...props });
    }
  }
  /**
   * Equals `true` when no spring values are in the frameloop, and
   * no async animation is currently active.
   */
  get idle() {
    return !this._state.asyncTo && Object.values(this.springs).every((spring) => {
      return spring.idle && !spring.isDelayed && !spring.isPaused;
    });
  }
  get item() {
    return this._item;
  }
  set item(item) {
    this._item = item;
  }
  /** Get the current values of our springs */
  get() {
    const values = {};
    this.each((spring, key) => values[key] = spring.get());
    return values;
  }
  /** Set the current values without animating. */
  set(values) {
    for (const key in values) {
      const value = values[key];
      if (!is.und(value)) {
        this.springs[key].set(value);
      }
    }
  }
  /** Push an update onto the queue of each value. */
  update(props) {
    if (props) {
      this.queue.push(createUpdate(props));
    }
    return this;
  }
  /**
   * Start the queued animations for every spring, and resolve the returned
   * promise once all queued animations have finished or been cancelled.
   *
   * When you pass a queue (instead of nothing), that queue is used instead of
   * the queued animations added with the `update` method, which are left alone.
   */
  start(props) {
    let { queue } = this;
    if (props) {
      queue = toArray(props).map(createUpdate);
    } else {
      this.queue = [];
    }
    if (this._flush) {
      return this._flush(this, queue);
    }
    prepareKeys(this, queue);
    return flushUpdateQueue(this, queue);
  }
  /** @internal */
  stop(arg, keys) {
    if (arg !== !!arg) {
      keys = arg;
    }
    if (keys) {
      const springs = this.springs;
      each(toArray(keys), (key) => springs[key].stop(!!arg));
    } else {
      stopAsync(this._state, this._lastAsyncId);
      this.each((spring) => spring.stop(!!arg));
    }
    return this;
  }
  /** Freeze the active animation in time */
  pause(keys) {
    if (is.und(keys)) {
      this.start({ pause: true });
    } else {
      const springs = this.springs;
      each(toArray(keys), (key) => springs[key].pause());
    }
    return this;
  }
  /** Resume the animation if paused. */
  resume(keys) {
    if (is.und(keys)) {
      this.start({ pause: false });
    } else {
      const springs = this.springs;
      each(toArray(keys), (key) => springs[key].resume());
    }
    return this;
  }
  /** Call a function once per spring value */
  each(iterator) {
    eachProp(this.springs, iterator);
  }
  /** @internal Called at the end of every animation frame */
  _onFrame() {
    const { onStart, onChange, onRest } = this._events;
    const active = this._active.size > 0;
    const changed = this._changed.size > 0;
    if (active && !this._started || changed && !this._started) {
      this._started = true;
      flush(onStart, ([onStart2, result]) => {
        result.value = this.get();
        onStart2(result, this, this._item);
      });
    }
    const idle = !active && this._started;
    const values = changed || idle && onRest.size ? this.get() : null;
    if (changed && onChange.size) {
      flush(onChange, ([onChange2, result]) => {
        result.value = values;
        onChange2(result, this, this._item);
      });
    }
    if (idle) {
      this._started = false;
      flush(onRest, ([onRest2, result]) => {
        result.value = values;
        onRest2(result, this, this._item);
      });
    }
  }
  /** @internal */
  eventObserved(event) {
    if (event.type == "change") {
      this._changed.add(event.parent);
      if (!event.idle) {
        this._active.add(event.parent);
      }
    } else if (event.type == "idle") {
      this._active.delete(event.parent);
    } else return;
    raf.onFrame(this._onFrame);
  }
};
function flushUpdateQueue(ctrl, queue) {
  return Promise.all(queue.map((props) => flushUpdate(ctrl, props))).then(
    (results) => getCombinedResult(ctrl, results)
  );
}
async function flushUpdate(ctrl, props, isLoop) {
  const { keys, to: to22, from, loop: loop2, onRest, onResolve } = props;
  const defaults2 = is.obj(props.default) && props.default;
  if (loop2) {
    props.loop = false;
  }
  if (to22 === false) props.to = null;
  if (from === false) props.from = null;
  const asyncTo = is.arr(to22) || is.fun(to22) ? to22 : void 0;
  if (asyncTo) {
    props.to = void 0;
    props.onRest = void 0;
    if (defaults2) {
      defaults2.onRest = void 0;
    }
  } else {
    each(BATCHED_EVENTS, (key) => {
      const handler = props[key];
      if (is.fun(handler)) {
        const queue = ctrl["_events"][key];
        props[key] = ({ finished, cancelled }) => {
          const result2 = queue.get(handler);
          if (result2) {
            if (!finished) result2.finished = false;
            if (cancelled) result2.cancelled = true;
          } else {
            queue.set(handler, {
              value: null,
              finished: finished || false,
              cancelled: cancelled || false
            });
          }
        };
        if (defaults2) {
          defaults2[key] = props[key];
        }
      }
    });
  }
  const state = ctrl["_state"];
  if (props.pause === !state.paused) {
    state.paused = props.pause;
    flushCalls(props.pause ? state.pauseQueue : state.resumeQueue);
  } else if (state.paused) {
    props.pause = true;
  }
  const promises = (keys || Object.keys(ctrl.springs)).map(
    (key) => ctrl.springs[key].start(props)
  );
  const cancel = props.cancel === true || getDefaultProp(props, "cancel") === true;
  if (asyncTo || cancel && state.asyncId) {
    promises.push(
      scheduleProps(++ctrl["_lastAsyncId"], {
        props,
        state,
        actions: {
          pause: noop,
          resume: noop,
          start(props2, resolve) {
            if (cancel) {
              stopAsync(state, ctrl["_lastAsyncId"]);
              resolve(getCancelledResult(ctrl));
            } else {
              props2.onRest = onRest;
              resolve(
                runAsync(
                  asyncTo,
                  props2,
                  state,
                  ctrl
                )
              );
            }
          }
        }
      })
    );
  }
  if (state.paused) {
    await new Promise((resume) => {
      state.resumeQueue.add(resume);
    });
  }
  const result = getCombinedResult(ctrl, await Promise.all(promises));
  if (loop2 && result.finished && !(isLoop && result.noop)) {
    const nextProps = createLoopUpdate(props, loop2, to22);
    if (nextProps) {
      prepareKeys(ctrl, [nextProps]);
      return flushUpdate(ctrl, nextProps, true);
    }
  }
  if (onResolve) {
    raf.batchedUpdates(() => onResolve(result, ctrl, ctrl.item));
  }
  return result;
}
function getSprings(ctrl, props) {
  const springs = { ...ctrl.springs };
  if (props) {
    each(toArray(props), (props2) => {
      if (is.und(props2.keys)) {
        props2 = createUpdate(props2);
      }
      if (!is.obj(props2.to)) {
        props2 = { ...props2, to: void 0 };
      }
      prepareSprings(springs, props2, (key) => {
        return createSpring(key);
      });
    });
  }
  setSprings(ctrl, springs);
  return springs;
}
function setSprings(ctrl, springs) {
  eachProp(springs, (spring, key) => {
    if (!ctrl.springs[key]) {
      ctrl.springs[key] = spring;
      addFluidObserver(spring, ctrl);
    }
  });
}
function createSpring(key, observer) {
  const spring = new SpringValue();
  spring.key = key;
  if (observer) {
    addFluidObserver(spring, observer);
  }
  return spring;
}
function prepareSprings(springs, props, create) {
  if (props.keys) {
    each(props.keys, (key) => {
      const spring = springs[key] || (springs[key] = create(key));
      spring["_prepareNode"](props);
    });
  }
}
function prepareKeys(ctrl, queue) {
  each(queue, (props) => {
    prepareSprings(ctrl.springs, props, (key) => {
      return createSpring(key, ctrl);
    });
  });
}
var SpringContext = React2.createContext({
  pause: false,
  immediate: false
});
var SpringRef = () => {
  const current = [];
  const SpringRef2 = function(props) {
    deprecateDirectCall();
    const results = [];
    each(current, (ctrl, i6) => {
      if (is.und(props)) {
        results.push(ctrl.start());
      } else {
        const update22 = _getProps(props, ctrl, i6);
        if (update22) {
          results.push(ctrl.start(update22));
        }
      }
    });
    return results;
  };
  SpringRef2.current = current;
  SpringRef2.add = function(ctrl) {
    if (!current.includes(ctrl)) {
      current.push(ctrl);
    }
  };
  SpringRef2.delete = function(ctrl) {
    const i6 = current.indexOf(ctrl);
    if (~i6) current.splice(i6, 1);
  };
  SpringRef2.pause = function() {
    each(current, (ctrl) => ctrl.pause(...arguments));
    return this;
  };
  SpringRef2.resume = function() {
    each(current, (ctrl) => ctrl.resume(...arguments));
    return this;
  };
  SpringRef2.set = function(values) {
    each(current, (ctrl, i6) => {
      const update22 = is.fun(values) ? values(i6, ctrl) : values;
      if (update22) {
        ctrl.set(update22);
      }
    });
  };
  SpringRef2.start = function(props) {
    const results = [];
    each(current, (ctrl, i6) => {
      if (is.und(props)) {
        results.push(ctrl.start());
      } else {
        const update22 = this._getProps(props, ctrl, i6);
        if (update22) {
          results.push(ctrl.start(update22));
        }
      }
    });
    return results;
  };
  SpringRef2.stop = function() {
    each(current, (ctrl) => ctrl.stop(...arguments));
    return this;
  };
  SpringRef2.update = function(props) {
    each(current, (ctrl, i6) => ctrl.update(this._getProps(props, ctrl, i6)));
    return this;
  };
  const _getProps = function(arg, ctrl, index2) {
    return is.fun(arg) ? arg(index2, ctrl) : arg;
  };
  SpringRef2._getProps = _getProps;
  return SpringRef2;
};
function useSprings(length, props, deps) {
  const propsFn = is.fun(props) && props;
  if (propsFn && !deps) deps = [];
  const ref = (0, import_react10.useMemo)(
    () => propsFn || arguments.length == 3 ? SpringRef() : void 0,
    []
  );
  const layoutId = (0, import_react10.useRef)(0);
  const forceUpdate = useForceUpdate();
  const state = (0, import_react10.useMemo)(
    () => ({
      ctrls: [],
      queue: [],
      flush(ctrl, updates2) {
        const springs2 = getSprings(ctrl, updates2);
        const canFlushSync = layoutId.current > 0 && !state.queue.length && !Object.keys(springs2).some((key) => !ctrl.springs[key]);
        return canFlushSync ? flushUpdateQueue(ctrl, updates2) : new Promise((resolve) => {
          setSprings(ctrl, springs2);
          state.queue.push(() => {
            resolve(flushUpdateQueue(ctrl, updates2));
          });
          forceUpdate();
        });
      }
    }),
    []
  );
  const ctrls = (0, import_react10.useRef)([...state.ctrls]);
  const updates = (0, import_react10.useRef)([]);
  const prevLength = usePrev(length) || 0;
  (0, import_react10.useMemo)(() => {
    each(ctrls.current.slice(length, prevLength), (ctrl) => {
      detachRefs(ctrl, ref);
      ctrl.stop(true);
    });
    ctrls.current.length = length;
    declareUpdates(prevLength, length);
  }, [length]);
  (0, import_react10.useMemo)(() => {
    declareUpdates(0, Math.min(prevLength, length));
  }, deps);
  function declareUpdates(startIndex, endIndex) {
    for (let i6 = startIndex; i6 < endIndex; i6++) {
      const ctrl = ctrls.current[i6] || (ctrls.current[i6] = new Controller(null, state.flush));
      const update22 = propsFn ? propsFn(i6, ctrl) : props[i6];
      if (update22) {
        updates.current[i6] = declareUpdate(update22);
      }
    }
  }
  const springs = ctrls.current.map(
    (ctrl, i6) => getSprings(ctrl, updates.current[i6])
  );
  const context = (0, import_react10.useContext)(SpringContext);
  const prevContext = usePrev(context);
  const hasContext = context !== prevContext && hasProps(context);
  useIsomorphicLayoutEffect(() => {
    layoutId.current++;
    state.ctrls = ctrls.current;
    const { queue } = state;
    if (queue.length) {
      state.queue = [];
      each(queue, (cb) => cb());
    }
    each(ctrls.current, (ctrl, i6) => {
      ref == null ? void 0 : ref.add(ctrl);
      if (hasContext) {
        ctrl.start({ default: context });
      }
      const update22 = updates.current[i6];
      if (update22) {
        replaceRef(ctrl, update22.ref);
        if (ctrl.ref) {
          ctrl.queue.push(update22);
        } else {
          ctrl.start(update22);
        }
      }
    });
  });
  useOnce(() => () => {
    each(state.ctrls, (ctrl) => ctrl.stop(true));
  });
  const values = springs.map((x3) => ({ ...x3 }));
  return ref ? [values, ref] : values;
}
function useSpring(props, deps) {
  const isFn = is.fun(props);
  const [[values], ref] = useSprings(
    1,
    isFn ? props : [props],
    isFn ? deps || [] : deps
  );
  return isFn || arguments.length == 2 ? [values, ref] : values;
}
function useTransition(data, props, deps) {
  const propsFn = is.fun(props) && props;
  const {
    reset,
    sort: sort2,
    trail = 0,
    expires = true,
    exitBeforeEnter = false,
    onDestroyed,
    ref: propsRef,
    config: propsConfig
  } = propsFn ? propsFn() : props;
  const ref = (0, import_react13.useMemo)(
    () => propsFn || arguments.length == 3 ? SpringRef() : void 0,
    []
  );
  const items = toArray(data);
  const transitions = [];
  const usedTransitions = (0, import_react13.useRef)(null);
  const prevTransitions = reset ? null : usedTransitions.current;
  useIsomorphicLayoutEffect(() => {
    usedTransitions.current = transitions;
  });
  useOnce(() => {
    each(transitions, (t5) => {
      ref == null ? void 0 : ref.add(t5.ctrl);
      t5.ctrl.ref = ref;
    });
    return () => {
      each(usedTransitions.current, (t5) => {
        if (t5.expired) {
          clearTimeout(t5.expirationId);
        }
        detachRefs(t5.ctrl, ref);
        t5.ctrl.stop(true);
      });
    };
  });
  const keys = getKeys(items, propsFn ? propsFn() : props, prevTransitions);
  const expired = reset && usedTransitions.current || [];
  useIsomorphicLayoutEffect(
    () => each(expired, ({ ctrl, item, key }) => {
      detachRefs(ctrl, ref);
      callProp(onDestroyed, item, key);
    })
  );
  const reused = [];
  if (prevTransitions)
    each(prevTransitions, (t5, i6) => {
      if (t5.expired) {
        clearTimeout(t5.expirationId);
        expired.push(t5);
      } else {
        i6 = reused[i6] = keys.indexOf(t5.key);
        if (~i6) transitions[i6] = t5;
      }
    });
  each(items, (item, i6) => {
    if (!transitions[i6]) {
      transitions[i6] = {
        key: keys[i6],
        item,
        phase: "mount",
        ctrl: new Controller()
      };
      transitions[i6].ctrl.item = item;
    }
  });
  if (reused.length) {
    let i6 = -1;
    const { leave } = propsFn ? propsFn() : props;
    each(reused, (keyIndex, prevIndex) => {
      const t5 = prevTransitions[prevIndex];
      if (~keyIndex) {
        i6 = transitions.indexOf(t5);
        transitions[i6] = { ...t5, item: items[keyIndex] };
      } else if (leave) {
        transitions.splice(++i6, 0, t5);
      }
    });
  }
  if (is.fun(sort2)) {
    transitions.sort((a4, b5) => sort2(a4.item, b5.item));
  }
  let delay = -trail;
  const forceUpdate = useForceUpdate();
  const defaultProps = getDefaultProps(props);
  const changes = /* @__PURE__ */ new Map();
  const exitingTransitions = (0, import_react13.useRef)(/* @__PURE__ */ new Map());
  const forceChange = (0, import_react13.useRef)(false);
  each(transitions, (t5, i6) => {
    const key = t5.key;
    const prevPhase = t5.phase;
    const p4 = propsFn ? propsFn() : props;
    let to22;
    let phase;
    const propsDelay = callProp(p4.delay || 0, key);
    if (prevPhase == "mount") {
      to22 = p4.enter;
      phase = "enter";
    } else {
      const isLeave = keys.indexOf(key) < 0;
      if (prevPhase != "leave") {
        if (isLeave) {
          to22 = p4.leave;
          phase = "leave";
        } else if (to22 = p4.update) {
          phase = "update";
        } else return;
      } else if (!isLeave) {
        to22 = p4.enter;
        phase = "enter";
      } else return;
    }
    to22 = callProp(to22, t5.item, i6);
    to22 = is.obj(to22) ? inferTo(to22) : { to: to22 };
    if (!to22.config) {
      const config2 = propsConfig || defaultProps.config;
      to22.config = callProp(config2, t5.item, i6, phase);
    }
    delay += trail;
    const payload = {
      ...defaultProps,
      // we need to add our props.delay value you here.
      delay: propsDelay + delay,
      ref: propsRef,
      immediate: p4.immediate,
      // This prevents implied resets.
      reset: false,
      // Merge any phase-specific props.
      ...to22
    };
    if (phase == "enter" && is.und(payload.from)) {
      const p22 = propsFn ? propsFn() : props;
      const from = is.und(p22.initial) || prevTransitions ? p22.from : p22.initial;
      payload.from = callProp(from, t5.item, i6);
    }
    const { onResolve } = payload;
    payload.onResolve = (result) => {
      callProp(onResolve, result);
      const transitions2 = usedTransitions.current;
      const t22 = transitions2.find((t32) => t32.key === key);
      if (!t22) return;
      if (result.cancelled && t22.phase != "update") {
        return;
      }
      if (t22.ctrl.idle) {
        const idle = transitions2.every((t32) => t32.ctrl.idle);
        if (t22.phase == "leave") {
          const expiry = callProp(expires, t22.item);
          if (expiry !== false) {
            const expiryMs = expiry === true ? 0 : expiry;
            t22.expired = true;
            if (!idle && expiryMs > 0) {
              if (expiryMs <= 2147483647)
                t22.expirationId = setTimeout(forceUpdate, expiryMs);
              return;
            }
          }
        }
        if (idle && transitions2.some((t32) => t32.expired)) {
          exitingTransitions.current.delete(t22);
          if (exitBeforeEnter) {
            forceChange.current = true;
          }
          forceUpdate();
        }
      }
    };
    const springs = getSprings(t5.ctrl, payload);
    if (phase === "leave" && exitBeforeEnter) {
      exitingTransitions.current.set(t5, { phase, springs, payload });
    } else {
      changes.set(t5, { phase, springs, payload });
    }
  });
  const context = (0, import_react13.useContext)(SpringContext);
  const prevContext = usePrev(context);
  const hasContext = context !== prevContext && hasProps(context);
  useIsomorphicLayoutEffect(() => {
    if (hasContext) {
      each(transitions, (t5) => {
        t5.ctrl.start({ default: context });
      });
    }
  }, [context]);
  each(changes, (_2, t5) => {
    if (exitingTransitions.current.size) {
      const ind = transitions.findIndex((state) => state.key === t5.key);
      transitions.splice(ind, 1);
    }
  });
  useIsomorphicLayoutEffect(
    () => {
      each(
        exitingTransitions.current.size ? exitingTransitions.current : changes,
        ({ phase, payload }, t5) => {
          const { ctrl } = t5;
          t5.phase = phase;
          ref == null ? void 0 : ref.add(ctrl);
          if (hasContext && phase == "enter") {
            ctrl.start({ default: context });
          }
          if (payload) {
            replaceRef(ctrl, payload.ref);
            if ((ctrl.ref || ref) && !forceChange.current) {
              ctrl.update(payload);
            } else {
              ctrl.start(payload);
              if (forceChange.current) {
                forceChange.current = false;
              }
            }
          }
        }
      );
    },
    reset ? void 0 : deps
  );
  const renderTransitions = (render) => React22.createElement(React22.Fragment, null, transitions.map((t5, i6) => {
    const { springs } = changes.get(t5) || t5.ctrl;
    const elem = render({ ...springs }, t5.item, t5, i6);
    return elem && elem.type ? React22.createElement(
      elem.type,
      {
        ...elem.props,
        key: is.str(t5.key) || is.num(t5.key) ? t5.key : t5.ctrl.id,
        ref: elem.ref
      }
    ) : elem;
  }));
  return ref ? [renderTransitions, ref] : renderTransitions;
}
var nextKey = 1;
function getKeys(items, { key, keys = key }, prevTransitions) {
  if (keys === null) {
    const reused = /* @__PURE__ */ new Set();
    return items.map((item) => {
      const t5 = prevTransitions && prevTransitions.find(
        (t22) => t22.item === item && t22.phase !== "leave" && !reused.has(t22)
      );
      if (t5) {
        reused.add(t5);
        return t5.key;
      }
      return nextKey++;
    });
  }
  return is.und(keys) ? items : is.fun(keys) ? items.map(keys) : toArray(keys);
}
var Interpolation = class extends FrameValue {
  constructor(source, args) {
    super();
    this.source = source;
    this.idle = true;
    this._active = /* @__PURE__ */ new Set();
    this.calc = createInterpolator(...args);
    const value = this._get();
    const nodeType = getAnimatedType(value);
    setAnimated(this, nodeType.create(value));
  }
  advance(_dt) {
    const value = this._get();
    const oldValue = this.get();
    if (!isEqual(value, oldValue)) {
      getAnimated(this).setValue(value);
      this._onChange(value, this.idle);
    }
    if (!this.idle && checkIdle(this._active)) {
      becomeIdle(this);
    }
  }
  _get() {
    const inputs = is.arr(this.source) ? this.source.map(getFluidValue) : toArray(getFluidValue(this.source));
    return this.calc(...inputs);
  }
  _start() {
    if (this.idle && !checkIdle(this._active)) {
      this.idle = false;
      each(getPayload(this), (node) => {
        node.done = false;
      });
      if (globals_exports.skipAnimation) {
        raf.batchedUpdates(() => this.advance());
        becomeIdle(this);
      } else {
        frameLoop.start(this);
      }
    }
  }
  // Observe our sources only when we're observed.
  _attach() {
    let priority2 = 1;
    each(toArray(this.source), (source) => {
      if (hasFluidValue(source)) {
        addFluidObserver(source, this);
      }
      if (isFrameValue(source)) {
        if (!source.idle) {
          this._active.add(source);
        }
        priority2 = Math.max(priority2, source.priority + 1);
      }
    });
    this.priority = priority2;
    this._start();
  }
  // Stop observing our sources once we have no observers.
  _detach() {
    each(toArray(this.source), (source) => {
      if (hasFluidValue(source)) {
        removeFluidObserver(source, this);
      }
    });
    this._active.clear();
    becomeIdle(this);
  }
  /** @internal */
  eventObserved(event) {
    if (event.type == "change") {
      if (event.idle) {
        this.advance();
      } else {
        this._active.add(event.parent);
        this._start();
      }
    } else if (event.type == "idle") {
      this._active.delete(event.parent);
    } else if (event.type == "priority") {
      this.priority = toArray(this.source).reduce(
        (highest, parent) => Math.max(highest, (isFrameValue(parent) ? parent.priority : 0) + 1),
        0
      );
    }
  }
};
function isIdle(source) {
  return source.idle !== false;
}
function checkIdle(active) {
  return !active.size || Array.from(active).every(isIdle);
}
function becomeIdle(self2) {
  if (!self2.idle) {
    self2.idle = true;
    each(getPayload(self2), (node) => {
      node.done = true;
    });
    callFluidObservers(self2, {
      type: "idle",
      parent: self2
    });
  }
}
var to2 = (source, ...args) => new Interpolation(source, args);
globals_exports.assign({
  createStringInterpolator: createStringInterpolator2,
  to: (source, args) => new Interpolation(source, args)
});
var update2 = frameLoop.advance;

// node_modules/@react-spring/web/dist/react-spring_web.modern.mjs
var import_react_dom = __toESM(require_react_dom(), 1);
var isCustomPropRE = /^--/;
function dangerousStyleValue(name, value) {
  if (value == null || typeof value === "boolean" || value === "") return "";
  if (typeof value === "number" && value !== 0 && !isCustomPropRE.test(name) && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]))
    return value + "px";
  return ("" + value).trim();
}
var attributeCache = {};
function applyAnimatedValues(instance, props) {
  if (!instance.nodeType || !instance.setAttribute) {
    return false;
  }
  const isFilterElement = instance.nodeName === "filter" || instance.parentNode && instance.parentNode.nodeName === "filter";
  const {
    className,
    style,
    children,
    scrollTop,
    scrollLeft,
    viewBox,
    ...attributes
  } = props;
  const values = Object.values(attributes);
  const names = Object.keys(attributes).map(
    (name) => isFilterElement || instance.hasAttribute(name) ? name : attributeCache[name] || (attributeCache[name] = name.replace(
      /([A-Z])/g,
      // Attributes are written in dash case
      (n6) => "-" + n6.toLowerCase()
    ))
  );
  if (children !== void 0) {
    instance.textContent = children;
  }
  for (const name in style) {
    if (style.hasOwnProperty(name)) {
      const value = dangerousStyleValue(name, style[name]);
      if (isCustomPropRE.test(name)) {
        instance.style.setProperty(name, value);
      } else {
        instance.style[name] = value;
      }
    }
  }
  names.forEach((name, i6) => {
    instance.setAttribute(name, values[i6]);
  });
  if (className !== void 0) {
    instance.className = className;
  }
  if (scrollTop !== void 0) {
    instance.scrollTop = scrollTop;
  }
  if (scrollLeft !== void 0) {
    instance.scrollLeft = scrollLeft;
  }
  if (viewBox !== void 0) {
    instance.setAttribute("viewBox", viewBox);
  }
}
var isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  // SVG-related properties
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};
var prefixKey = (prefix2, key) => prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
var prefixes = ["Webkit", "Ms", "Moz", "O"];
isUnitlessNumber = Object.keys(isUnitlessNumber).reduce((acc, prop) => {
  prefixes.forEach((prefix2) => acc[prefixKey(prefix2, prop)] = acc[prop]);
  return acc;
}, isUnitlessNumber);
var domTransforms = /^(matrix|translate|scale|rotate|skew)/;
var pxTransforms = /^(translate)/;
var degTransforms = /^(rotate|skew)/;
var addUnit = (value, unit) => is.num(value) && value !== 0 ? value + unit : value;
var isValueIdentity = (value, id) => is.arr(value) ? value.every((v2) => isValueIdentity(v2, id)) : is.num(value) ? value === id : parseFloat(value) === id;
var AnimatedStyle = class extends AnimatedObject {
  constructor({ x: x3, y: y3, z: z5, ...style }) {
    const inputs = [];
    const transforms = [];
    if (x3 || y3 || z5) {
      inputs.push([x3 || 0, y3 || 0, z5 || 0]);
      transforms.push((xyz) => [
        `translate3d(${xyz.map((v2) => addUnit(v2, "px")).join(",")})`,
        // prettier-ignore
        isValueIdentity(xyz, 0)
      ]);
    }
    eachProp(style, (value, key) => {
      if (key === "transform") {
        inputs.push([value || ""]);
        transforms.push((transform) => [transform, transform === ""]);
      } else if (domTransforms.test(key)) {
        delete style[key];
        if (is.und(value)) return;
        const unit = pxTransforms.test(key) ? "px" : degTransforms.test(key) ? "deg" : "";
        inputs.push(toArray(value));
        transforms.push(
          key === "rotate3d" ? ([x22, y22, z22, deg]) => [
            `rotate3d(${x22},${y22},${z22},${addUnit(deg, unit)})`,
            isValueIdentity(deg, 0)
          ] : (input) => [
            `${key}(${input.map((v2) => addUnit(v2, unit)).join(",")})`,
            isValueIdentity(input, key.startsWith("scale") ? 1 : 0)
          ]
        );
      }
    });
    if (inputs.length) {
      style.transform = new FluidTransform(inputs, transforms);
    }
    super(style);
  }
};
var FluidTransform = class extends FluidValue {
  constructor(inputs, transforms) {
    super();
    this.inputs = inputs;
    this.transforms = transforms;
    this._value = null;
  }
  get() {
    return this._value || (this._value = this._get());
  }
  _get() {
    let transform = "";
    let identity = true;
    each(this.inputs, (input, i6) => {
      const arg1 = getFluidValue(input[0]);
      const [t5, id] = this.transforms[i6](
        is.arr(arg1) ? arg1 : input.map(getFluidValue)
      );
      transform += " " + t5;
      identity = identity && id;
    });
    return identity ? "none" : transform;
  }
  // Start observing our inputs once we have an observer.
  observerAdded(count2) {
    if (count2 == 1)
      each(
        this.inputs,
        (input) => each(
          input,
          (value) => hasFluidValue(value) && addFluidObserver(value, this)
        )
      );
  }
  // Stop observing our inputs once we have no observers.
  observerRemoved(count2) {
    if (count2 == 0)
      each(
        this.inputs,
        (input) => each(
          input,
          (value) => hasFluidValue(value) && removeFluidObserver(value, this)
        )
      );
  }
  eventObserved(event) {
    if (event.type == "change") {
      this._value = null;
    }
    callFluidObservers(this, event);
  }
};
var primitives = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
];
globals_exports.assign({
  batchedUpdates: import_react_dom.unstable_batchedUpdates,
  createStringInterpolator: createStringInterpolator2,
  colors: colors2
});
var host = createHost(primitives, {
  applyAnimatedValues,
  createAnimatedStyle: (style) => new AnimatedStyle(style),
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getComponentProps: ({ scrollTop, scrollLeft, ...props }) => props
});
var animated = host.animated;

// node_modules/@nivo/theming/dist/nivo-theming.mjs
var import_react15 = __toESM(require_react(), 1);
var import_merge = __toESM(require_merge(), 1);
var import_get = __toESM(require_get(), 1);
var import_set = __toESM(require_set(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
function u() {
  return u = Object.assign ? Object.assign.bind() : function(t5) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var o6 = arguments[e8];
      for (var i6 in o6) ({}).hasOwnProperty.call(o6, i6) && (t5[i6] = o6[i6]);
    }
    return t5;
  }, u.apply(null, arguments);
}
function d(t5, e8) {
  if (null == t5) return {};
  var o6 = {};
  for (var i6 in t5) if ({}.hasOwnProperty.call(t5, i6)) {
    if (-1 !== e8.indexOf(i6)) continue;
    o6[i6] = t5[i6];
  }
  return o6;
}
var s = ["outlineWidth", "outlineColor", "outlineOpacity"];
var b = function(t5) {
  return t5.outlineWidth, t5.outlineColor, t5.outlineOpacity, d(t5, s);
};
var y = ["axis.ticks.text", "axis.legend.text", "legends.title.text", "legends.text", "legends.ticks.text", "legends.title.text", "labels.text", "dots.text", "markers.text", "annotations.text"];
var W = function(t5, e8) {
  return u({}, e8, t5);
};
var O = function(t5, e8) {
  var o6 = (0, import_merge.default)({}, t5, e8);
  return y.forEach(function(t6) {
    (0, import_set.default)(o6, t6, W((0, import_get.default)(o6, t6), o6.text));
  }), o6;
};
var C = { background: "transparent", text: { fontFamily: "sans-serif", fontSize: 11, fill: "#333333", outlineWidth: 0, outlineColor: "#ffffff", outlineOpacity: 1 }, axis: { domain: { line: { stroke: "transparent", strokeWidth: 1 } }, ticks: { line: { stroke: "#777777", strokeWidth: 1 }, text: {} }, legend: { text: { fontSize: 12 } } }, grid: { line: { stroke: "#dddddd", strokeWidth: 1 } }, legends: { hidden: { symbol: { fill: "#333333", opacity: 0.6 }, text: { fill: "#333333", opacity: 0.6 } }, text: {}, ticks: { line: { stroke: "#777777", strokeWidth: 1 }, text: { fontSize: 10 } }, title: { text: {} } }, labels: { text: {} }, markers: { lineColor: "#000000", lineStrokeWidth: 1, text: {} }, dots: { text: {} }, tooltip: { container: { background: "white", color: "inherit", fontSize: "inherit", borderRadius: "2px", boxShadow: "0 1px 2px rgba(0, 0, 0, 0.25)", padding: "5px 9px" }, basic: { whiteSpace: "pre", display: "flex", alignItems: "center" }, chip: { marginRight: 7 }, table: {}, tableCell: { padding: "3px 5px" }, tableCellValue: { fontWeight: "bold" } }, crosshair: { line: { stroke: "#000000", strokeWidth: 1, strokeOpacity: 0.75, strokeDasharray: "6 6" } }, annotations: { text: { fontSize: 13, outlineWidth: 2, outlineColor: "#ffffff", outlineOpacity: 1 }, link: { stroke: "#000000", strokeWidth: 1, outlineWidth: 2, outlineColor: "#ffffff", outlineOpacity: 1 }, outline: { fill: "none", stroke: "#000000", strokeWidth: 2, outlineWidth: 2, outlineColor: "#ffffff", outlineOpacity: 1 }, symbol: { fill: "#000000", outlineWidth: 2, outlineColor: "#ffffff", outlineOpacity: 1 } } };
var L = function(e8) {
  return (0, import_react15.useMemo)(function() {
    return O(C, e8);
  }, [e8]);
};
var S = (0, import_react15.createContext)(null);
var j = {};
var z = function(t5) {
  var e8 = t5.theme, o6 = void 0 === e8 ? j : e8, i6 = t5.children, n6 = L(o6);
  return (0, import_jsx_runtime.jsx)(S.Provider, { value: n6, children: i6 });
};
var M = function() {
  var t5 = (0, import_react15.useContext)(S);
  if (null === t5) throw new Error("Unable to find the theme, did you forget to wrap your component with ThemeProvider?");
  return t5;
};

// node_modules/@nivo/tooltip/dist/nivo-tooltip.mjs
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
function v() {
  return v = Object.assign ? Object.assign.bind() : function(t5) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var n6 = arguments[i6];
      for (var o6 in n6) ({}).hasOwnProperty.call(n6, o6) && (t5[o6] = n6[o6]);
    }
    return t5;
  }, v.apply(null, arguments);
}
var x = ["basic", "chip", "container", "table", "tableCell", "tableCellValue"];
var m = { pointerEvents: "none", position: "absolute", zIndex: 10, top: 0, left: 0 };
var b2 = function(t5, i6) {
  return "translate(" + t5 + "px, " + i6 + "px)";
};
var g = (0, import_react16.memo)(function(t5) {
  var n6, o6 = t5.position, r6 = t5.anchor, e8 = t5.children, l5 = M(), u4 = Dr(), y3 = u4.animate, f3 = u4.config, g2 = sn(), w4 = g2[0], T2 = g2[1], C4 = (0, import_react16.useRef)(false), E2 = void 0, P5 = false, V2 = T2.width > 0 && T2.height > 0, O4 = Math.round(o6[0]), N3 = Math.round(o6[1]);
  V2 && ("top" === r6 ? (O4 -= T2.width / 2, N3 -= T2.height + 14) : "right" === r6 ? (O4 += 14, N3 -= T2.height / 2) : "bottom" === r6 ? (O4 -= T2.width / 2, N3 += 14) : "left" === r6 ? (O4 -= T2.width + 14, N3 -= T2.height / 2) : "center" === r6 && (O4 -= T2.width / 2, N3 -= T2.height / 2), E2 = { transform: b2(O4, N3) }, C4.current || (P5 = true), C4.current = [O4, N3]);
  var j4 = useSpring({ to: E2, config: f3, immediate: !y3 || P5 }), k3 = l5.tooltip;
  k3.basic, k3.chip, k3.container, k3.table, k3.tableCell, k3.tableCellValue;
  var z5 = function(t6, i6) {
    if (null == t6) return {};
    var n7 = {};
    for (var o7 in t6) if ({}.hasOwnProperty.call(t6, o7)) {
      if (-1 !== i6.indexOf(o7)) continue;
      n7[o7] = t6[o7];
    }
    return n7;
  }(k3, x), A3 = v({}, m, z5, { transform: null != (n6 = j4.transform) ? n6 : b2(O4, N3), opacity: j4.transform ? 1 : 0 });
  return (0, import_jsx_runtime2.jsx)(animated.div, { ref: w4, style: A3, children: e8 });
});
g.displayName = "TooltipWrapper";
var w = (0, import_react16.memo)(function(t5) {
  var i6 = t5.size, n6 = void 0 === i6 ? 12 : i6, o6 = t5.color, r6 = t5.style;
  return (0, import_jsx_runtime2.jsx)("span", { style: v({ display: "block", width: n6, height: n6, background: o6 }, void 0 === r6 ? {} : r6) });
});
var T = (0, import_react16.memo)(function(t5) {
  var i6, n6 = t5.id, o6 = t5.value, r6 = t5.format, e8 = t5.enableChip, l5 = void 0 !== e8 && e8, a4 = t5.color, c8 = t5.renderContent, s5 = M(), h2 = hn(r6);
  if ("function" == typeof c8) i6 = c8();
  else {
    var f3 = o6;
    void 0 !== h2 && void 0 !== f3 && (f3 = h2(f3)), i6 = (0, import_jsx_runtime2.jsxs)("div", { style: s5.tooltip.basic, children: [l5 && (0, import_jsx_runtime2.jsx)(w, { color: a4, style: s5.tooltip.chip }), void 0 !== f3 ? (0, import_jsx_runtime2.jsxs)("span", { children: [n6, ": ", (0, import_jsx_runtime2.jsx)("strong", { children: "" + f3 })] }) : n6] });
  }
  return (0, import_jsx_runtime2.jsx)("div", { style: s5.tooltip.container, role: "tooltip", children: i6 });
});
var C2 = { width: "100%", borderCollapse: "collapse" };
var E = (0, import_react16.memo)(function(t5) {
  var i6, n6 = t5.title, o6 = t5.rows, r6 = void 0 === o6 ? [] : o6, e8 = t5.renderContent, l5 = M();
  return r6.length ? (i6 = "function" == typeof e8 ? e8() : (0, import_jsx_runtime2.jsxs)("div", { children: [n6 && n6, (0, import_jsx_runtime2.jsx)("table", { style: v({}, C2, l5.tooltip.table), children: (0, import_jsx_runtime2.jsx)("tbody", { children: r6.map(function(t6, i7) {
    return (0, import_jsx_runtime2.jsx)("tr", { children: t6.map(function(t7, i8) {
      return (0, import_jsx_runtime2.jsx)("td", { style: l5.tooltip.tableCell, children: t7 }, i8);
    }) }, i7);
  }) }) })] }), (0, import_jsx_runtime2.jsx)("div", { style: l5.tooltip.container, children: i6 })) : null;
});
E.displayName = "TableTooltip";
var P = (0, import_react16.memo)(function(t5) {
  var i6 = t5.x0, o6 = t5.x1, r6 = t5.y0, e8 = t5.y1, l5 = M(), h2 = Dr(), u4 = h2.animate, y3 = h2.config, f3 = (0, import_react16.useMemo)(function() {
    return v({}, l5.crosshair.line, { pointerEvents: "none" });
  }, [l5.crosshair.line]), x3 = useSpring({ x1: i6, x2: o6, y1: r6, y2: e8, config: y3, immediate: !u4 });
  return (0, import_jsx_runtime2.jsx)(animated.line, v({}, x3, { fill: "none", style: f3 }));
});
P.displayName = "CrosshairLine";
var V = (0, import_react16.memo)(function(t5) {
  var i6, n6, o6 = t5.width, r6 = t5.height, e8 = t5.type, l5 = t5.x, a4 = t5.y;
  return "cross" === e8 ? (i6 = { x0: l5, x1: l5, y0: 0, y1: r6 }, n6 = { x0: 0, x1: o6, y0: a4, y1: a4 }) : "top-left" === e8 ? (i6 = { x0: l5, x1: l5, y0: 0, y1: a4 }, n6 = { x0: 0, x1: l5, y0: a4, y1: a4 }) : "top" === e8 ? i6 = { x0: l5, x1: l5, y0: 0, y1: a4 } : "top-right" === e8 ? (i6 = { x0: l5, x1: l5, y0: 0, y1: a4 }, n6 = { x0: l5, x1: o6, y0: a4, y1: a4 }) : "right" === e8 ? n6 = { x0: l5, x1: o6, y0: a4, y1: a4 } : "bottom-right" === e8 ? (i6 = { x0: l5, x1: l5, y0: a4, y1: r6 }, n6 = { x0: l5, x1: o6, y0: a4, y1: a4 }) : "bottom" === e8 ? i6 = { x0: l5, x1: l5, y0: a4, y1: r6 } : "bottom-left" === e8 ? (i6 = { x0: l5, x1: l5, y0: a4, y1: r6 }, n6 = { x0: 0, x1: l5, y0: a4, y1: a4 }) : "left" === e8 ? n6 = { x0: 0, x1: l5, y0: a4, y1: a4 } : "x" === e8 ? i6 = { x0: l5, x1: l5, y0: 0, y1: r6 } : "y" === e8 && (n6 = { x0: 0, x1: o6, y0: a4, y1: a4 }), (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [i6 && (0, import_jsx_runtime2.jsx)(P, { x0: i6.x0, x1: i6.x1, y0: i6.y0, y1: i6.y1 }), n6 && (0, import_jsx_runtime2.jsx)(P, { x0: n6.x0, x1: n6.x1, y0: n6.y0, y1: n6.y1 })] });
});
V.displayName = "Crosshair";
var O2 = (0, import_react16.createContext)({ showTooltipAt: function() {
}, showTooltipFromEvent: function() {
}, hideTooltip: function() {
} });
var N = { isVisible: false, position: [null, null], content: null, anchor: null };
var j2 = (0, import_react16.createContext)(N);
var k = function(t5) {
  var i6 = (0, import_react16.useState)(N), o6 = i6[0], l5 = i6[1], a4 = (0, import_react16.useCallback)(function(t6, i7, n6) {
    var o7 = i7[0], r6 = i7[1];
    void 0 === n6 && (n6 = "top"), l5({ isVisible: true, position: [o7, r6], anchor: n6, content: t6 });
  }, [l5]), c8 = (0, import_react16.useCallback)(function(i7, n6, o7) {
    void 0 === o7 && (o7 = "top");
    var r6 = t5.current.getBoundingClientRect(), e8 = t5.current.offsetWidth, a5 = e8 === r6.width ? 1 : e8 / r6.width, c9 = "touches" in n6 ? n6.touches[0] : n6, s6 = c9.clientX, h2 = c9.clientY, u4 = (s6 - r6.left) * a5, d5 = (h2 - r6.top) * a5;
    "left" !== o7 && "right" !== o7 || (o7 = u4 < r6.width / 2 ? "right" : "left"), l5({ isVisible: true, position: [u4, d5], anchor: o7, content: i7 });
  }, [t5, l5]), s5 = (0, import_react16.useCallback)(function() {
    l5(N);
  }, [l5]);
  return { actions: (0, import_react16.useMemo)(function() {
    return { showTooltipAt: a4, showTooltipFromEvent: c8, hideTooltip: s5 };
  }, [a4, c8, s5]), state: o6 };
};
var z2 = function() {
  var t5 = (0, import_react16.useContext)(O2);
  if (void 0 === t5) throw new Error("useTooltip must be used within a TooltipProvider");
  return t5;
};
var A = function() {
  var t5 = (0, import_react16.useContext)(j2);
  if (void 0 === t5) throw new Error("useTooltipState must be used within a TooltipProvider");
  return t5;
};
var F = function(t5) {
  return t5.isVisible;
};
var M2 = function() {
  var t5 = A();
  return F(t5) ? (0, import_jsx_runtime2.jsx)(g, { position: t5.position, anchor: t5.anchor, children: t5.content }) : null;
};
var W2 = function(t5) {
  var i6 = t5.container, n6 = t5.children, o6 = k(i6), r6 = o6.actions, e8 = o6.state;
  return (0, import_jsx_runtime2.jsx)(O2.Provider, { value: r6, children: (0, import_jsx_runtime2.jsx)(j2.Provider, { value: e8, children: n6 }) });
};

// node_modules/@nivo/core/dist/nivo-core.mjs
var import_isString = __toESM(require_isString(), 1);
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);

// node_modules/react-virtualized-auto-sizer/dist/react-virtualized-auto-sizer.esm.js
var import_react17 = __toESM(require_react());
var windowObject;
if (typeof window !== "undefined") {
  windowObject = window;
} else if (typeof self !== "undefined") {
  windowObject = self;
} else {
  windowObject = global;
}
var cancelFrame = null;
var requestFrame = null;
var TIMEOUT_DURATION = 20;
var clearTimeoutFn = windowObject.clearTimeout;
var setTimeoutFn = windowObject.setTimeout;
var cancelAnimationFrameFn = windowObject.cancelAnimationFrame || windowObject.mozCancelAnimationFrame || windowObject.webkitCancelAnimationFrame;
var requestAnimationFrameFn = windowObject.requestAnimationFrame || windowObject.mozRequestAnimationFrame || windowObject.webkitRequestAnimationFrame;
if (cancelAnimationFrameFn == null || requestAnimationFrameFn == null) {
  cancelFrame = clearTimeoutFn;
  requestFrame = function requestAnimationFrameViaSetTimeout(callback) {
    return setTimeoutFn(callback, TIMEOUT_DURATION);
  };
} else {
  cancelFrame = function cancelFrame2([animationFrameID, timeoutID]) {
    cancelAnimationFrameFn(animationFrameID);
    clearTimeoutFn(timeoutID);
  };
  requestFrame = function requestAnimationFrameWithSetTimeoutFallback(callback) {
    const animationFrameID = requestAnimationFrameFn(function animationFrameCallback() {
      clearTimeoutFn(timeoutID);
      callback();
    });
    const timeoutID = setTimeoutFn(function timeoutCallback() {
      cancelAnimationFrameFn(animationFrameID);
      callback();
    }, TIMEOUT_DURATION);
    return [animationFrameID, timeoutID];
  };
}
function createDetectElementResize(nonce) {
  let animationKeyframes;
  let animationName;
  let animationStartEvent;
  let animationStyle;
  let checkTriggers;
  let resetTriggers;
  let scrollListener;
  const attachEvent = typeof document !== "undefined" && document.attachEvent;
  if (!attachEvent) {
    resetTriggers = function(element) {
      const triggers = element.__resizeTriggers__, expand = triggers.firstElementChild, contract = triggers.lastElementChild, expandChild = expand.firstElementChild;
      contract.scrollLeft = contract.scrollWidth;
      contract.scrollTop = contract.scrollHeight;
      expandChild.style.width = expand.offsetWidth + 1 + "px";
      expandChild.style.height = expand.offsetHeight + 1 + "px";
      expand.scrollLeft = expand.scrollWidth;
      expand.scrollTop = expand.scrollHeight;
    };
    checkTriggers = function(element) {
      return element.offsetWidth !== element.__resizeLast__.width || element.offsetHeight !== element.__resizeLast__.height;
    };
    scrollListener = function(e8) {
      if (e8.target.className && typeof e8.target.className.indexOf === "function" && e8.target.className.indexOf("contract-trigger") < 0 && e8.target.className.indexOf("expand-trigger") < 0) {
        return;
      }
      const element = this;
      resetTriggers(this);
      if (this.__resizeRAF__) {
        cancelFrame(this.__resizeRAF__);
      }
      this.__resizeRAF__ = requestFrame(function animationFrame() {
        if (checkTriggers(element)) {
          element.__resizeLast__.width = element.offsetWidth;
          element.__resizeLast__.height = element.offsetHeight;
          element.__resizeListeners__.forEach(function forEachResizeListener(fn3) {
            fn3.call(element, e8);
          });
        }
      });
    };
    let animation = false;
    let keyframeprefix = "";
    animationStartEvent = "animationstart";
    const domPrefixes = "Webkit Moz O ms".split(" ");
    let startEvents = "webkitAnimationStart animationstart oAnimationStart MSAnimationStart".split(" ");
    let pfx = "";
    {
      const elm = document.createElement("fakeelement");
      if (elm.style.animationName !== void 0) {
        animation = true;
      }
      if (animation === false) {
        for (let i6 = 0; i6 < domPrefixes.length; i6++) {
          if (elm.style[domPrefixes[i6] + "AnimationName"] !== void 0) {
            pfx = domPrefixes[i6];
            keyframeprefix = "-" + pfx.toLowerCase() + "-";
            animationStartEvent = startEvents[i6];
            animation = true;
            break;
          }
        }
      }
    }
    animationName = "resizeanim";
    animationKeyframes = "@" + keyframeprefix + "keyframes " + animationName + " { from { opacity: 0; } to { opacity: 0; } } ";
    animationStyle = keyframeprefix + "animation: 1ms " + animationName + "; ";
  }
  const createStyles = function(doc) {
    if (!doc.getElementById("detectElementResize")) {
      const css = (animationKeyframes ? animationKeyframes : "") + ".resize-triggers { " + (animationStyle ? animationStyle : "") + 'visibility: hidden; opacity: 0; } .resize-triggers, .resize-triggers > div, .contract-trigger:before { content: " "; display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; z-index: -1; } .resize-triggers > div { background: #eee; overflow: auto; } .contract-trigger:before { width: 200%; height: 200%; }', head = doc.head || doc.getElementsByTagName("head")[0], style = doc.createElement("style");
      style.id = "detectElementResize";
      style.type = "text/css";
      if (nonce != null) {
        style.setAttribute("nonce", nonce);
      }
      if (style.styleSheet) {
        style.styleSheet.cssText = css;
      } else {
        style.appendChild(doc.createTextNode(css));
      }
      head.appendChild(style);
    }
  };
  const addResizeListener = function(element, fn3) {
    if (attachEvent) {
      element.attachEvent("onresize", fn3);
    } else {
      if (!element.__resizeTriggers__) {
        const doc = element.ownerDocument;
        const elementStyle = windowObject.getComputedStyle(element);
        if (elementStyle && elementStyle.position === "static") {
          element.style.position = "relative";
        }
        createStyles(doc);
        element.__resizeLast__ = {};
        element.__resizeListeners__ = [];
        (element.__resizeTriggers__ = doc.createElement("div")).className = "resize-triggers";
        const expandTrigger = doc.createElement("div");
        expandTrigger.className = "expand-trigger";
        expandTrigger.appendChild(doc.createElement("div"));
        const contractTrigger = doc.createElement("div");
        contractTrigger.className = "contract-trigger";
        element.__resizeTriggers__.appendChild(expandTrigger);
        element.__resizeTriggers__.appendChild(contractTrigger);
        element.appendChild(element.__resizeTriggers__);
        resetTriggers(element);
        element.addEventListener("scroll", scrollListener, true);
        if (animationStartEvent) {
          element.__resizeTriggers__.__animationListener__ = function animationListener(e8) {
            if (e8.animationName === animationName) {
              resetTriggers(element);
            }
          };
          element.__resizeTriggers__.addEventListener(animationStartEvent, element.__resizeTriggers__.__animationListener__);
        }
      }
      element.__resizeListeners__.push(fn3);
    }
  };
  const removeResizeListener = function(element, fn3) {
    if (attachEvent) {
      element.detachEvent("onresize", fn3);
    } else {
      element.__resizeListeners__.splice(element.__resizeListeners__.indexOf(fn3), 1);
      if (!element.__resizeListeners__.length) {
        element.removeEventListener("scroll", scrollListener, true);
        if (element.__resizeTriggers__.__animationListener__) {
          element.__resizeTriggers__.removeEventListener(animationStartEvent, element.__resizeTriggers__.__animationListener__);
          element.__resizeTriggers__.__animationListener__ = null;
        }
        try {
          element.__resizeTriggers__ = !element.removeChild(element.__resizeTriggers__);
        } catch (e8) {
        }
      }
    }
  };
  return {
    addResizeListener,
    removeResizeListener
  };
}
var AutoSizer = class extends import_react17.Component {
  constructor(...args) {
    super(...args);
    this.state = {
      height: this.props.defaultHeight || 0,
      width: this.props.defaultWidth || 0
    };
    this._autoSizer = null;
    this._detectElementResize = null;
    this._didLogDeprecationWarning = false;
    this._parentNode = null;
    this._resizeObserver = null;
    this._timeoutId = null;
    this._onResize = () => {
      this._timeoutId = null;
      const {
        disableHeight,
        disableWidth,
        onResize: onResize2
      } = this.props;
      if (this._parentNode) {
        const style = window.getComputedStyle(this._parentNode) || {};
        const paddingLeft = parseFloat(style.paddingLeft || "0");
        const paddingRight = parseFloat(style.paddingRight || "0");
        const paddingTop = parseFloat(style.paddingTop || "0");
        const paddingBottom = parseFloat(style.paddingBottom || "0");
        const rect = this._parentNode.getBoundingClientRect();
        const height = rect.height - paddingTop - paddingBottom;
        const width = rect.width - paddingLeft - paddingRight;
        if (!disableHeight && this.state.height !== height || !disableWidth && this.state.width !== width) {
          this.setState({
            height,
            width
          });
          const maybeLogDeprecationWarning = () => {
            if (!this._didLogDeprecationWarning) {
              this._didLogDeprecationWarning = true;
              console.warn("scaledWidth and scaledHeight parameters have been deprecated; use width and height instead");
            }
          };
          if (typeof onResize2 === "function") {
            onResize2({
              height,
              width,
              // TODO Remove these params in the next major release
              get scaledHeight() {
                maybeLogDeprecationWarning();
                return height;
              },
              get scaledWidth() {
                maybeLogDeprecationWarning();
                return width;
              }
            });
          }
        }
      }
    };
    this._setRef = (autoSizer) => {
      this._autoSizer = autoSizer;
    };
  }
  componentDidMount() {
    const {
      nonce
    } = this.props;
    const parentNode = this._autoSizer ? this._autoSizer.parentNode : null;
    if (parentNode != null && parentNode.ownerDocument && parentNode.ownerDocument.defaultView && parentNode instanceof parentNode.ownerDocument.defaultView.HTMLElement) {
      this._parentNode = parentNode;
      const ResizeObserverInstance = parentNode.ownerDocument.defaultView.ResizeObserver;
      if (ResizeObserverInstance != null) {
        this._resizeObserver = new ResizeObserverInstance(() => {
          this._timeoutId = setTimeout(this._onResize, 0);
        });
        this._resizeObserver.observe(parentNode);
      } else {
        this._detectElementResize = createDetectElementResize(nonce);
        this._detectElementResize.addResizeListener(parentNode, this._onResize);
      }
      this._onResize();
    }
  }
  componentWillUnmount() {
    if (this._parentNode) {
      if (this._detectElementResize) {
        this._detectElementResize.removeResizeListener(this._parentNode, this._onResize);
      }
      if (this._timeoutId !== null) {
        clearTimeout(this._timeoutId);
      }
      if (this._resizeObserver) {
        this._resizeObserver.disconnect();
      }
    }
  }
  render() {
    const {
      children,
      defaultHeight,
      defaultWidth,
      disableHeight = false,
      disableWidth = false,
      doNotBailOutOnEmptyChildren = false,
      nonce,
      onResize: onResize2,
      style = {},
      tagName = "div",
      ...rest
    } = this.props;
    const {
      height,
      width
    } = this.state;
    const outerStyle = {
      overflow: "visible"
    };
    const childParams = {};
    let bailoutOnChildren = false;
    if (!disableHeight) {
      if (height === 0) {
        bailoutOnChildren = true;
      }
      outerStyle.height = 0;
      childParams.height = height;
      childParams.scaledHeight = height;
    }
    if (!disableWidth) {
      if (width === 0) {
        bailoutOnChildren = true;
      }
      outerStyle.width = 0;
      childParams.width = width;
      childParams.scaledWidth = width;
    }
    if (doNotBailOutOnEmptyChildren) {
      bailoutOnChildren = false;
    }
    return (0, import_react17.createElement)(tagName, {
      ref: this._setRef,
      style: {
        ...outerStyle,
        ...style
      },
      ...rest
    }, !bailoutOnChildren && children(childParams));
  }
};

// node_modules/use-debounce/dist/index.module.js
var import_react18 = __toESM(require_react());
function c(e8, u4, c8, i6) {
  var a4 = this, o6 = (0, import_react18.useRef)(null), f3 = (0, import_react18.useRef)(0), l5 = (0, import_react18.useRef)(0), v2 = (0, import_react18.useRef)(null), m3 = (0, import_react18.useRef)([]), d5 = (0, import_react18.useRef)(), g2 = (0, import_react18.useRef)(), p4 = (0, import_react18.useRef)(e8), w4 = (0, import_react18.useRef)(true);
  p4.current = e8;
  var s5 = "undefined" != typeof window, x3 = !u4 && 0 !== u4 && s5;
  if ("function" != typeof e8) throw new TypeError("Expected a function");
  u4 = +u4 || 0;
  var h2 = !!(c8 = c8 || {}).leading, y3 = !("trailing" in c8) || !!c8.trailing, F3 = "maxWait" in c8, A3 = "debounceOnServer" in c8 && !!c8.debounceOnServer, D = F3 ? Math.max(+c8.maxWait || 0, u4) : null;
  (0, import_react18.useEffect)(function() {
    return w4.current = true, function() {
      w4.current = false;
    };
  }, []);
  var T2 = (0, import_react18.useMemo)(function() {
    var r6 = function(r7) {
      var n7 = m3.current, t6 = d5.current;
      return m3.current = d5.current = null, f3.current = r7, l5.current = l5.current || r7, g2.current = p4.current.apply(t6, n7);
    }, n6 = function(r7, n7) {
      x3 && cancelAnimationFrame(v2.current), v2.current = x3 ? requestAnimationFrame(r7) : setTimeout(r7, n7);
    }, t5 = function(r7) {
      if (!w4.current) return false;
      var n7 = r7 - o6.current;
      return !o6.current || n7 >= u4 || n7 < 0 || F3 && r7 - f3.current >= D;
    }, e9 = function(n7) {
      return v2.current = null, y3 && m3.current ? r6(n7) : (m3.current = d5.current = null, g2.current);
    }, c9 = function r7() {
      var c10 = Date.now();
      if (h2 && l5.current === f3.current && T3(), t5(c10)) return e9(c10);
      if (w4.current) {
        var i7 = u4 - (c10 - o6.current), a5 = F3 ? Math.min(i7, D - (c10 - f3.current)) : i7;
        n6(r7, a5);
      }
    }, T3 = function() {
      i6 && i6({});
    }, W5 = function() {
      if (s5 || A3) {
        var e11 = Date.now(), i7 = t5(e11);
        if (m3.current = [].slice.call(arguments), d5.current = a4, o6.current = e11, i7) {
          if (!v2.current && w4.current) return f3.current = o6.current, n6(c9, u4), h2 ? r6(o6.current) : g2.current;
          if (F3) return n6(c9, u4), r6(o6.current);
        }
        return v2.current || n6(c9, u4), g2.current;
      }
    };
    return W5.cancel = function() {
      v2.current && (x3 ? cancelAnimationFrame(v2.current) : clearTimeout(v2.current)), f3.current = 0, m3.current = o6.current = d5.current = v2.current = null;
    }, W5.isPending = function() {
      return !!v2.current;
    }, W5.flush = function() {
      return v2.current ? e9(Date.now()) : g2.current;
    }, W5;
  }, [h2, F3, u4, D, y3, x3, s5, A3, i6]);
  return T2;
}
function i3(r6, n6) {
  return r6 === n6;
}
function a(n6, t5, a4) {
  var o6 = a4 && a4.equalityFn || i3, f3 = (0, import_react18.useRef)(n6), l5 = (0, import_react18.useState)({})[1], v2 = c((0, import_react18.useCallback)(function(r6) {
    f3.current = r6, l5({});
  }, [l5]), t5, a4, l5), m3 = (0, import_react18.useRef)(n6);
  return o6(m3.current, n6) || (v2(n6), m3.current = n6), [f3.current, v2];
}

// node_modules/@nivo/core/dist/nivo-core.mjs
init_src2();
var import_without = __toESM(require_without(), 1);
init_src3();
init_src4();
init_src5();
var import_last = __toESM(require_last(), 1);
var import_isArray = __toESM(require_isArray(), 1);
var import_isFunction = __toESM(require_isFunction(), 1);

// node_modules/@nivo/core/node_modules/d3-format/src/formatDecimal.js
function formatDecimal_default(x3) {
  return Math.abs(x3 = Math.round(x3)) >= 1e21 ? x3.toLocaleString("en").replace(/,/g, "") : x3.toString(10);
}
function formatDecimalParts(x3, p4) {
  if ((i6 = (x3 = p4 ? x3.toExponential(p4 - 1) : x3.toExponential()).indexOf("e")) < 0) return null;
  var i6, coefficient = x3.slice(0, i6);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x3.slice(i6 + 1)
  ];
}

// node_modules/@nivo/core/node_modules/d3-format/src/exponent.js
function exponent_default(x3) {
  return x3 = formatDecimalParts(Math.abs(x3)), x3 ? x3[1] : NaN;
}

// node_modules/@nivo/core/node_modules/d3-format/src/formatGroup.js
function formatGroup_default(grouping, thousands) {
  return function(value, width) {
    var i6 = value.length, t5 = [], j4 = 0, g2 = grouping[0], length = 0;
    while (i6 > 0 && g2 > 0) {
      if (length + g2 + 1 > width) g2 = Math.max(1, width - length);
      t5.push(value.substring(i6 -= g2, i6 + g2));
      if ((length += g2 + 1) > width) break;
      g2 = grouping[j4 = (j4 + 1) % grouping.length];
    }
    return t5.reverse().join(thousands);
  };
}

// node_modules/@nivo/core/node_modules/d3-format/src/formatNumerals.js
function formatNumerals_default(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i6) {
      return numerals[+i6];
    });
  };
}

// node_modules/@nivo/core/node_modules/d3-format/src/formatSpecifier.js
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};

// node_modules/@nivo/core/node_modules/d3-format/src/formatTrim.js
function formatTrim_default(s5) {
  out: for (var n6 = s5.length, i6 = 1, i0 = -1, i1; i6 < n6; ++i6) {
    switch (s5[i6]) {
      case ".":
        i0 = i1 = i6;
        break;
      case "0":
        if (i0 === 0) i0 = i6;
        i1 = i6;
        break;
      default:
        if (!+s5[i6]) break out;
        if (i0 > 0) i0 = 0;
        break;
    }
  }
  return i0 > 0 ? s5.slice(0, i0) + s5.slice(i1 + 1) : s5;
}

// node_modules/@nivo/core/node_modules/d3-format/src/formatPrefixAuto.js
var prefixExponent;
function formatPrefixAuto_default(x3, p4) {
  var d5 = formatDecimalParts(x3, p4);
  if (!d5) return x3 + "";
  var coefficient = d5[0], exponent = d5[1], i6 = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n6 = coefficient.length;
  return i6 === n6 ? coefficient : i6 > n6 ? coefficient + new Array(i6 - n6 + 1).join("0") : i6 > 0 ? coefficient.slice(0, i6) + "." + coefficient.slice(i6) : "0." + new Array(1 - i6).join("0") + formatDecimalParts(x3, Math.max(0, p4 + i6 - 1))[0];
}

// node_modules/@nivo/core/node_modules/d3-format/src/formatRounded.js
function formatRounded_default(x3, p4) {
  var d5 = formatDecimalParts(x3, p4);
  if (!d5) return x3 + "";
  var coefficient = d5[0], exponent = d5[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

// node_modules/@nivo/core/node_modules/d3-format/src/formatTypes.js
var formatTypes_default = {
  "%": function(x3, p4) {
    return (x3 * 100).toFixed(p4);
  },
  "b": function(x3) {
    return Math.round(x3).toString(2);
  },
  "c": function(x3) {
    return x3 + "";
  },
  "d": formatDecimal_default,
  "e": function(x3, p4) {
    return x3.toExponential(p4);
  },
  "f": function(x3, p4) {
    return x3.toFixed(p4);
  },
  "g": function(x3, p4) {
    return x3.toPrecision(p4);
  },
  "o": function(x3) {
    return Math.round(x3).toString(8);
  },
  "p": function(x3, p4) {
    return formatRounded_default(x3 * 100, p4);
  },
  "r": formatRounded_default,
  "s": formatPrefixAuto_default,
  "X": function(x3) {
    return Math.round(x3).toString(16).toUpperCase();
  },
  "x": function(x3) {
    return Math.round(x3).toString(16);
  }
};

// node_modules/@nivo/core/node_modules/d3-format/src/identity.js
function identity_default(x3) {
  return x3;
}

// node_modules/@nivo/core/node_modules/d3-format/src/locale.js
var map = Array.prototype.map;
var prefixes2 = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function locale_default(locale3) {
  var group2 = locale3.grouping === void 0 || locale3.thousands === void 0 ? identity_default : formatGroup_default(map.call(locale3.grouping, Number), locale3.thousands + ""), currencyPrefix = locale3.currency === void 0 ? "" : locale3.currency[0] + "", currencySuffix = locale3.currency === void 0 ? "" : locale3.currency[1] + "", decimal = locale3.decimal === void 0 ? "." : locale3.decimal + "", numerals = locale3.numerals === void 0 ? identity_default : formatNumerals_default(map.call(locale3.numerals, String)), percent = locale3.percent === void 0 ? "%" : locale3.percent + "", minus = locale3.minus === void 0 ? "-" : locale3.minus + "", nan = locale3.nan === void 0 ? "NaN" : locale3.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill = specifier.fill, align = specifier.align, sign = specifier.sign, symbol = specifier.symbol, zero = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type = specifier.type;
    if (type === "n") comma = true, type = "g";
    else if (!formatTypes_default[type]) precision === void 0 && (precision = 12), trim = true, type = "g";
    if (zero || fill === "0" && align === "=") zero = true, fill = "0", align = "=";
    var prefix2 = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";
    var formatType = formatTypes_default[type], maybeSuffix = /[defgprs%]/.test(type);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format2(value) {
      var valuePrefix = prefix2, valueSuffix = suffix, i6, n6, c8;
      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;
        var valueNegative = value < 0 || 1 / value < 0;
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
        if (trim) value = formatTrim_default(value);
        if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;
        valuePrefix = (valueNegative ? sign === "(" ? sign : minus : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes2[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");
        if (maybeSuffix) {
          i6 = -1, n6 = value.length;
          while (++i6 < n6) {
            if (c8 = value.charCodeAt(i6), 48 > c8 || c8 > 57) {
              valueSuffix = (c8 === 46 ? decimal + value.slice(i6 + 1) : value.slice(i6)) + valueSuffix;
              value = value.slice(0, i6);
              break;
            }
          }
        }
      }
      if (comma && !zero) value = group2(value, Infinity);
      var length = valuePrefix.length + value.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill) : "";
      if (comma && zero) value = group2(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
      switch (align) {
        case "<":
          value = valuePrefix + value + valueSuffix + padding;
          break;
        case "=":
          value = valuePrefix + padding + value + valueSuffix;
          break;
        case "^":
          value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
          break;
        default:
          value = padding + valuePrefix + value + valueSuffix;
          break;
      }
      return numerals(value);
    }
    format2.toString = function() {
      return specifier + "";
    };
    return format2;
  }
  function formatPrefix2(specifier, value) {
    var f3 = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e8 = Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3, k3 = Math.pow(10, -e8), prefix2 = prefixes2[8 + e8 / 3];
    return function(value2) {
      return f3(k3 * value2) + prefix2;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}

// node_modules/@nivo/core/node_modules/d3-format/src/defaultLocale.js
var locale;
var format;
var formatPrefix;
defaultLocale({
  decimal: ".",
  thousands: ",",
  grouping: [3],
  currency: ["$", ""],
  minus: "-"
});
function defaultLocale(definition) {
  locale = locale_default(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}

// node_modules/@nivo/core/node_modules/d3-time/src/interval.js
var t0 = /* @__PURE__ */ new Date();
var t1 = /* @__PURE__ */ new Date();
function newInterval(floori, offseti, count2, field) {
  function interval(date) {
    return floori(date = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+date)), date;
  }
  interval.floor = function(date) {
    return floori(date = /* @__PURE__ */ new Date(+date)), date;
  };
  interval.ceil = function(date) {
    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
  };
  interval.round = function(date) {
    var d0 = interval(date), d1 = interval.ceil(date);
    return date - d0 < d1 - date ? d0 : d1;
  };
  interval.offset = function(date, step) {
    return offseti(date = /* @__PURE__ */ new Date(+date), step == null ? 1 : Math.floor(step)), date;
  };
  interval.range = function(start2, stop2, step) {
    var range = [], previous;
    start2 = interval.ceil(start2);
    step = step == null ? 1 : Math.floor(step);
    if (!(start2 < stop2) || !(step > 0)) return range;
    do
      range.push(previous = /* @__PURE__ */ new Date(+start2)), offseti(start2, step), floori(start2);
    while (previous < start2 && start2 < stop2);
    return range;
  };
  interval.filter = function(test) {
    return newInterval(function(date) {
      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
    }, function(date, step) {
      if (date >= date) {
        if (step < 0) while (++step <= 0) {
          while (offseti(date, -1), !test(date)) {
          }
        }
        else while (--step >= 0) {
          while (offseti(date, 1), !test(date)) {
          }
        }
      }
    });
  };
  if (count2) {
    interval.count = function(start2, end) {
      t0.setTime(+start2), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count2(t0, t1));
    };
    interval.every = function(step) {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval : interval.filter(field ? function(d5) {
        return field(d5) % step === 0;
      } : function(d5) {
        return interval.count(0, d5) % step === 0;
      });
    };
  }
  return interval;
}

// node_modules/@nivo/core/node_modules/d3-time/src/millisecond.js
var millisecond = newInterval(function() {
}, function(date, step) {
  date.setTime(+date + step);
}, function(start2, end) {
  return end - start2;
});
millisecond.every = function(k3) {
  k3 = Math.floor(k3);
  if (!isFinite(k3) || !(k3 > 0)) return null;
  if (!(k3 > 1)) return millisecond;
  return newInterval(function(date) {
    date.setTime(Math.floor(date / k3) * k3);
  }, function(date, step) {
    date.setTime(+date + step * k3);
  }, function(start2, end) {
    return (end - start2) / k3;
  });
};
var millisecond_default = millisecond;
var milliseconds = millisecond.range;

// node_modules/@nivo/core/node_modules/d3-time/src/duration.js
var durationSecond = 1e3;
var durationMinute = durationSecond * 60;
var durationHour = durationMinute * 60;
var durationDay = durationHour * 24;
var durationWeek = durationDay * 7;
var durationMonth = durationDay * 30;
var durationYear = durationDay * 365;

// node_modules/@nivo/core/node_modules/d3-time/src/second.js
var second = newInterval(function(date) {
  date.setTime(date - date.getMilliseconds());
}, function(date, step) {
  date.setTime(+date + step * durationSecond);
}, function(start2, end) {
  return (end - start2) / durationSecond;
}, function(date) {
  return date.getUTCSeconds();
});
var second_default = second;
var seconds = second.range;

// node_modules/@nivo/core/node_modules/d3-time/src/minute.js
var minute = newInterval(function(date) {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond);
}, function(date, step) {
  date.setTime(+date + step * durationMinute);
}, function(start2, end) {
  return (end - start2) / durationMinute;
}, function(date) {
  return date.getMinutes();
});
var minute_default = minute;
var minutes = minute.range;

// node_modules/@nivo/core/node_modules/d3-time/src/hour.js
var hour = newInterval(function(date) {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute);
}, function(date, step) {
  date.setTime(+date + step * durationHour);
}, function(start2, end) {
  return (end - start2) / durationHour;
}, function(date) {
  return date.getHours();
});
var hour_default = hour;
var hours = hour.range;

// node_modules/@nivo/core/node_modules/d3-time/src/day.js
var day = newInterval(
  (date) => date.setHours(0, 0, 0, 0),
  (date, step) => date.setDate(date.getDate() + step),
  (start2, end) => (end - start2 - (end.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute) / durationDay,
  (date) => date.getDate() - 1
);
var day_default = day;
var days = day.range;

// node_modules/@nivo/core/node_modules/d3-time/src/week.js
function weekday(i6) {
  return newInterval(function(date) {
    date.setDate(date.getDate() - (date.getDay() + 7 - i6) % 7);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setDate(date.getDate() + step * 7);
  }, function(start2, end) {
    return (end - start2 - (end.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}
var sunday = weekday(0);
var monday = weekday(1);
var tuesday = weekday(2);
var wednesday = weekday(3);
var thursday = weekday(4);
var friday = weekday(5);
var saturday = weekday(6);
var sundays = sunday.range;
var mondays = monday.range;
var tuesdays = tuesday.range;
var wednesdays = wednesday.range;
var thursdays = thursday.range;
var fridays = friday.range;
var saturdays = saturday.range;

// node_modules/@nivo/core/node_modules/d3-time/src/month.js
var month = newInterval(function(date) {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setMonth(date.getMonth() + step);
}, function(start2, end) {
  return end.getMonth() - start2.getMonth() + (end.getFullYear() - start2.getFullYear()) * 12;
}, function(date) {
  return date.getMonth();
});
var month_default = month;
var months = month.range;

// node_modules/@nivo/core/node_modules/d3-time/src/year.js
var year = newInterval(function(date) {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setFullYear(date.getFullYear() + step);
}, function(start2, end) {
  return end.getFullYear() - start2.getFullYear();
}, function(date) {
  return date.getFullYear();
});
year.every = function(k3) {
  return !isFinite(k3 = Math.floor(k3)) || !(k3 > 0) ? null : newInterval(function(date) {
    date.setFullYear(Math.floor(date.getFullYear() / k3) * k3);
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setFullYear(date.getFullYear() + step * k3);
  });
};
var year_default = year;
var years = year.range;

// node_modules/@nivo/core/node_modules/d3-time/src/utcMinute.js
var utcMinute = newInterval(function(date) {
  date.setUTCSeconds(0, 0);
}, function(date, step) {
  date.setTime(+date + step * durationMinute);
}, function(start2, end) {
  return (end - start2) / durationMinute;
}, function(date) {
  return date.getUTCMinutes();
});
var utcMinute_default = utcMinute;
var utcMinutes = utcMinute.range;

// node_modules/@nivo/core/node_modules/d3-time/src/utcHour.js
var utcHour = newInterval(function(date) {
  date.setUTCMinutes(0, 0, 0);
}, function(date, step) {
  date.setTime(+date + step * durationHour);
}, function(start2, end) {
  return (end - start2) / durationHour;
}, function(date) {
  return date.getUTCHours();
});
var utcHour_default = utcHour;
var utcHours = utcHour.range;

// node_modules/@nivo/core/node_modules/d3-time/src/utcDay.js
var utcDay = newInterval(function(date) {
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCDate(date.getUTCDate() + step);
}, function(start2, end) {
  return (end - start2) / durationDay;
}, function(date) {
  return date.getUTCDate() - 1;
});
var utcDay_default = utcDay;
var utcDays = utcDay.range;

// node_modules/@nivo/core/node_modules/d3-time/src/utcWeek.js
function utcWeekday(i6) {
  return newInterval(function(date) {
    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i6) % 7);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCDate(date.getUTCDate() + step * 7);
  }, function(start2, end) {
    return (end - start2) / durationWeek;
  });
}
var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);
var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;

// node_modules/@nivo/core/node_modules/d3-time/src/utcMonth.js
var utcMonth = newInterval(function(date) {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCMonth(date.getUTCMonth() + step);
}, function(start2, end) {
  return end.getUTCMonth() - start2.getUTCMonth() + (end.getUTCFullYear() - start2.getUTCFullYear()) * 12;
}, function(date) {
  return date.getUTCMonth();
});
var utcMonth_default = utcMonth;
var utcMonths = utcMonth.range;

// node_modules/@nivo/core/node_modules/d3-time/src/utcYear.js
var utcYear = newInterval(function(date) {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCFullYear(date.getUTCFullYear() + step);
}, function(start2, end) {
  return end.getUTCFullYear() - start2.getUTCFullYear();
}, function(date) {
  return date.getUTCFullYear();
});
utcYear.every = function(k3) {
  return !isFinite(k3 = Math.floor(k3)) || !(k3 > 0) ? null : newInterval(function(date) {
    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k3) * k3);
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step * k3);
  });
};
var utcYear_default = utcYear;
var utcYears = utcYear.range;

// node_modules/@nivo/core/node_modules/d3-array/src/ascending.js
function ascending_default2(a4, b5) {
  return a4 < b5 ? -1 : a4 > b5 ? 1 : a4 >= b5 ? 0 : NaN;
}

// node_modules/@nivo/core/node_modules/d3-array/src/bisector.js
function bisector_default(f3) {
  let delta = f3;
  let compare = f3;
  if (f3.length === 1) {
    delta = (d5, x3) => f3(d5) - x3;
    compare = ascendingComparator(f3);
  }
  function left(a4, x3, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a4.length;
    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (compare(a4[mid], x3) < 0) lo = mid + 1;
      else hi = mid;
    }
    return lo;
  }
  function right(a4, x3, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a4.length;
    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (compare(a4[mid], x3) > 0) hi = mid;
      else lo = mid + 1;
    }
    return lo;
  }
  function center(a4, x3, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a4.length;
    const i6 = left(a4, x3, lo, hi - 1);
    return i6 > lo && delta(a4[i6 - 1], x3) > -delta(a4[i6], x3) ? i6 - 1 : i6;
  }
  return { left, center, right };
}
function ascendingComparator(f3) {
  return (d5, x3) => ascending_default2(f3(d5), x3);
}

// node_modules/@nivo/core/node_modules/d3-array/src/number.js
function number_default(x3) {
  return x3 === null ? NaN : +x3;
}

// node_modules/@nivo/core/node_modules/d3-array/src/bisect.js
var ascendingBisect = bisector_default(ascending_default2);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
var bisectCenter = bisector_default(number_default).center;

// node_modules/@nivo/core/node_modules/d3-array/src/array.js
var array = Array.prototype;
var slice = array.slice;
var map2 = array.map;

// node_modules/@nivo/core/node_modules/d3-array/src/ticks.js
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e22 = Math.sqrt(2);
function tickStep(start2, stop2, count2) {
  var step0 = Math.abs(stop2 - start2) / Math.max(0, count2), step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)), error = step0 / step1;
  if (error >= e10) step1 *= 10;
  else if (error >= e5) step1 *= 5;
  else if (error >= e22) step1 *= 2;
  return stop2 < start2 ? -step1 : step1;
}

// node_modules/@nivo/core/node_modules/d3-array/src/shuffle.js
var shuffle_default = shuffler(Math.random);
function shuffler(random) {
  return function shuffle(array2, i0 = 0, i1 = array2.length) {
    let m3 = i1 - (i0 = +i0);
    while (m3) {
      const i6 = random() * m3-- | 0, t5 = array2[m3 + i0];
      array2[m3 + i0] = array2[i6 + i0];
      array2[i6 + i0] = t5;
    }
    return array2;
  };
}

// node_modules/@nivo/core/node_modules/d3-time/src/ticks.js
function ticker(year2, month2, week, day2, hour2, minute2) {
  const tickIntervals = [
    [second_default, 1, durationSecond],
    [second_default, 5, 5 * durationSecond],
    [second_default, 15, 15 * durationSecond],
    [second_default, 30, 30 * durationSecond],
    [minute2, 1, durationMinute],
    [minute2, 5, 5 * durationMinute],
    [minute2, 15, 15 * durationMinute],
    [minute2, 30, 30 * durationMinute],
    [hour2, 1, durationHour],
    [hour2, 3, 3 * durationHour],
    [hour2, 6, 6 * durationHour],
    [hour2, 12, 12 * durationHour],
    [day2, 1, durationDay],
    [day2, 2, 2 * durationDay],
    [week, 1, durationWeek],
    [month2, 1, durationMonth],
    [month2, 3, 3 * durationMonth],
    [year2, 1, durationYear]
  ];
  function ticks(start2, stop2, count2) {
    const reverse2 = stop2 < start2;
    if (reverse2) [start2, stop2] = [stop2, start2];
    const interval = count2 && typeof count2.range === "function" ? count2 : tickInterval(start2, stop2, count2);
    const ticks2 = interval ? interval.range(start2, +stop2 + 1) : [];
    return reverse2 ? ticks2.reverse() : ticks2;
  }
  function tickInterval(start2, stop2, count2) {
    const target = Math.abs(stop2 - start2) / count2;
    const i6 = bisector_default(([, , step2]) => step2).right(tickIntervals, target);
    if (i6 === tickIntervals.length) return year2.every(tickStep(start2 / durationYear, stop2 / durationYear, count2));
    if (i6 === 0) return millisecond_default.every(Math.max(tickStep(start2, stop2, count2), 1));
    const [t5, step] = tickIntervals[target / tickIntervals[i6 - 1][2] < tickIntervals[i6][2] / target ? i6 - 1 : i6];
    return t5.every(step);
  }
  return [ticks, tickInterval];
}
var [utcTicks, utcTickInterval] = ticker(utcYear_default, utcMonth_default, utcSunday, utcDay_default, utcHour_default, utcMinute_default);
var [timeTicks, timeTickInterval] = ticker(year_default, month_default, sunday, day_default, hour_default, minute_default);

// node_modules/@nivo/core/node_modules/d3-time-format/src/locale.js
function localDate(d5) {
  if (0 <= d5.y && d5.y < 100) {
    var date = new Date(-1, d5.m, d5.d, d5.H, d5.M, d5.S, d5.L);
    date.setFullYear(d5.y);
    return date;
  }
  return new Date(d5.y, d5.m, d5.d, d5.H, d5.M, d5.S, d5.L);
}
function utcDate(d5) {
  if (0 <= d5.y && d5.y < 100) {
    var date = new Date(Date.UTC(-1, d5.m, d5.d, d5.H, d5.M, d5.S, d5.L));
    date.setUTCFullYear(d5.y);
    return date;
  }
  return new Date(Date.UTC(d5.y, d5.m, d5.d, d5.H, d5.M, d5.S, d5.L));
}
function newDate(y3, m3, d5) {
  return { y: y3, m: m3, d: d5, H: 0, M: 0, S: 0, L: 0 };
}
function formatLocale(locale3) {
  var locale_dateTime = locale3.dateTime, locale_date = locale3.date, locale_time = locale3.time, locale_periods = locale3.periods, locale_weekdays = locale3.days, locale_shortWeekdays = locale3.shortDays, locale_months = locale3.months, locale_shortMonths = locale3.shortMonths;
  var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "g": formatYearISO,
    "G": formatFullYearISO,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };
  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "g": formatUTCYearISO,
    "G": formatUTCFullYearISO,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };
  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "g": parseYear,
    "G": parseFullYear,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);
  function newFormat(specifier, formats2) {
    return function(date) {
      var string = [], i6 = -1, j4 = 0, n6 = specifier.length, c8, pad2, format2;
      if (!(date instanceof Date)) date = /* @__PURE__ */ new Date(+date);
      while (++i6 < n6) {
        if (specifier.charCodeAt(i6) === 37) {
          string.push(specifier.slice(j4, i6));
          if ((pad2 = pads[c8 = specifier.charAt(++i6)]) != null) c8 = specifier.charAt(++i6);
          else pad2 = c8 === "e" ? " " : "0";
          if (format2 = formats2[c8]) c8 = format2(date, pad2);
          string.push(c8);
          j4 = i6 + 1;
        }
      }
      string.push(specifier.slice(j4, i6));
      return string.join("");
    };
  }
  function newParse(specifier, Z) {
    return function(string) {
      var d5 = newDate(1900, void 0, 1), i6 = parseSpecifier(d5, specifier, string += "", 0), week, day2;
      if (i6 != string.length) return null;
      if ("Q" in d5) return new Date(d5.Q);
      if ("s" in d5) return new Date(d5.s * 1e3 + ("L" in d5 ? d5.L : 0));
      if (Z && !("Z" in d5)) d5.Z = 0;
      if ("p" in d5) d5.H = d5.H % 12 + d5.p * 12;
      if (d5.m === void 0) d5.m = "q" in d5 ? d5.q : 0;
      if ("V" in d5) {
        if (d5.V < 1 || d5.V > 53) return null;
        if (!("w" in d5)) d5.w = 1;
        if ("Z" in d5) {
          week = utcDate(newDate(d5.y, 0, 1)), day2 = week.getUTCDay();
          week = day2 > 4 || day2 === 0 ? utcMonday.ceil(week) : utcMonday(week);
          week = utcDay_default.offset(week, (d5.V - 1) * 7);
          d5.y = week.getUTCFullYear();
          d5.m = week.getUTCMonth();
          d5.d = week.getUTCDate() + (d5.w + 6) % 7;
        } else {
          week = localDate(newDate(d5.y, 0, 1)), day2 = week.getDay();
          week = day2 > 4 || day2 === 0 ? monday.ceil(week) : monday(week);
          week = day_default.offset(week, (d5.V - 1) * 7);
          d5.y = week.getFullYear();
          d5.m = week.getMonth();
          d5.d = week.getDate() + (d5.w + 6) % 7;
        }
      } else if ("W" in d5 || "U" in d5) {
        if (!("w" in d5)) d5.w = "u" in d5 ? d5.u % 7 : "W" in d5 ? 1 : 0;
        day2 = "Z" in d5 ? utcDate(newDate(d5.y, 0, 1)).getUTCDay() : localDate(newDate(d5.y, 0, 1)).getDay();
        d5.m = 0;
        d5.d = "W" in d5 ? (d5.w + 6) % 7 + d5.W * 7 - (day2 + 5) % 7 : d5.w + d5.U * 7 - (day2 + 6) % 7;
      }
      if ("Z" in d5) {
        d5.H += d5.Z / 100 | 0;
        d5.M += d5.Z % 100;
        return utcDate(d5);
      }
      return localDate(d5);
    };
  }
  function parseSpecifier(d5, specifier, string, j4) {
    var i6 = 0, n6 = specifier.length, m3 = string.length, c8, parse;
    while (i6 < n6) {
      if (j4 >= m3) return -1;
      c8 = specifier.charCodeAt(i6++);
      if (c8 === 37) {
        c8 = specifier.charAt(i6++);
        parse = parses[c8 in pads ? specifier.charAt(i6++) : c8];
        if (!parse || (j4 = parse(d5, string, j4)) < 0) return -1;
      } else if (c8 != string.charCodeAt(j4++)) {
        return -1;
      }
    }
    return j4;
  }
  function parsePeriod(d5, string, i6) {
    var n6 = periodRe.exec(string.slice(i6));
    return n6 ? (d5.p = periodLookup.get(n6[0].toLowerCase()), i6 + n6[0].length) : -1;
  }
  function parseShortWeekday(d5, string, i6) {
    var n6 = shortWeekdayRe.exec(string.slice(i6));
    return n6 ? (d5.w = shortWeekdayLookup.get(n6[0].toLowerCase()), i6 + n6[0].length) : -1;
  }
  function parseWeekday(d5, string, i6) {
    var n6 = weekdayRe.exec(string.slice(i6));
    return n6 ? (d5.w = weekdayLookup.get(n6[0].toLowerCase()), i6 + n6[0].length) : -1;
  }
  function parseShortMonth(d5, string, i6) {
    var n6 = shortMonthRe.exec(string.slice(i6));
    return n6 ? (d5.m = shortMonthLookup.get(n6[0].toLowerCase()), i6 + n6[0].length) : -1;
  }
  function parseMonth(d5, string, i6) {
    var n6 = monthRe.exec(string.slice(i6));
    return n6 ? (d5.m = monthLookup.get(n6[0].toLowerCase()), i6 + n6[0].length) : -1;
  }
  function parseLocaleDateTime(d5, string, i6) {
    return parseSpecifier(d5, locale_dateTime, string, i6);
  }
  function parseLocaleDate(d5, string, i6) {
    return parseSpecifier(d5, locale_date, string, i6);
  }
  function parseLocaleTime(d5, string, i6) {
    return parseSpecifier(d5, locale_time, string, i6);
  }
  function formatShortWeekday(d5) {
    return locale_shortWeekdays[d5.getDay()];
  }
  function formatWeekday(d5) {
    return locale_weekdays[d5.getDay()];
  }
  function formatShortMonth(d5) {
    return locale_shortMonths[d5.getMonth()];
  }
  function formatMonth(d5) {
    return locale_months[d5.getMonth()];
  }
  function formatPeriod(d5) {
    return locale_periods[+(d5.getHours() >= 12)];
  }
  function formatQuarter(d5) {
    return 1 + ~~(d5.getMonth() / 3);
  }
  function formatUTCShortWeekday(d5) {
    return locale_shortWeekdays[d5.getUTCDay()];
  }
  function formatUTCWeekday(d5) {
    return locale_weekdays[d5.getUTCDay()];
  }
  function formatUTCShortMonth(d5) {
    return locale_shortMonths[d5.getUTCMonth()];
  }
  function formatUTCMonth(d5) {
    return locale_months[d5.getUTCMonth()];
  }
  function formatUTCPeriod(d5) {
    return locale_periods[+(d5.getUTCHours() >= 12)];
  }
  function formatUTCQuarter(d5) {
    return 1 + ~~(d5.getUTCMonth() / 3);
  }
  return {
    format: function(specifier) {
      var f3 = newFormat(specifier += "", formats);
      f3.toString = function() {
        return specifier;
      };
      return f3;
    },
    parse: function(specifier) {
      var p4 = newParse(specifier += "", false);
      p4.toString = function() {
        return specifier;
      };
      return p4;
    },
    utcFormat: function(specifier) {
      var f3 = newFormat(specifier += "", utcFormats);
      f3.toString = function() {
        return specifier;
      };
      return f3;
    },
    utcParse: function(specifier) {
      var p4 = newParse(specifier += "", true);
      p4.toString = function() {
        return specifier;
      };
      return p4;
    }
  };
}
var pads = { "-": "", "_": " ", "0": "0" };
var numberRe = /^\s*\d+/;
var percentRe = /^%/;
var requoteRe = /[\\^$*+?|[\]().{}]/g;
function pad(value, fill, width) {
  var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length = string.length;
  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}
function requote(s5) {
  return s5.replace(requoteRe, "\\$&");
}
function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}
function formatLookup(names) {
  return new Map(names.map((name, i6) => [name.toLowerCase(), i6]));
}
function parseWeekdayNumberSunday(d5, string, i6) {
  var n6 = numberRe.exec(string.slice(i6, i6 + 1));
  return n6 ? (d5.w = +n6[0], i6 + n6[0].length) : -1;
}
function parseWeekdayNumberMonday(d5, string, i6) {
  var n6 = numberRe.exec(string.slice(i6, i6 + 1));
  return n6 ? (d5.u = +n6[0], i6 + n6[0].length) : -1;
}
function parseWeekNumberSunday(d5, string, i6) {
  var n6 = numberRe.exec(string.slice(i6, i6 + 2));
  return n6 ? (d5.U = +n6[0], i6 + n6[0].length) : -1;
}
function parseWeekNumberISO(d5, string, i6) {
  var n6 = numberRe.exec(string.slice(i6, i6 + 2));
  return n6 ? (d5.V = +n6[0], i6 + n6[0].length) : -1;
}
function parseWeekNumberMonday(d5, string, i6) {
  var n6 = numberRe.exec(string.slice(i6, i6 + 2));
  return n6 ? (d5.W = +n6[0], i6 + n6[0].length) : -1;
}
function parseFullYear(d5, string, i6) {
  var n6 = numberRe.exec(string.slice(i6, i6 + 4));
  return n6 ? (d5.y = +n6[0], i6 + n6[0].length) : -1;
}
function parseYear(d5, string, i6) {
  var n6 = numberRe.exec(string.slice(i6, i6 + 2));
  return n6 ? (d5.y = +n6[0] + (+n6[0] > 68 ? 1900 : 2e3), i6 + n6[0].length) : -1;
}
function parseZone(d5, string, i6) {
  var n6 = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i6, i6 + 6));
  return n6 ? (d5.Z = n6[1] ? 0 : -(n6[2] + (n6[3] || "00")), i6 + n6[0].length) : -1;
}
function parseQuarter(d5, string, i6) {
  var n6 = numberRe.exec(string.slice(i6, i6 + 1));
  return n6 ? (d5.q = n6[0] * 3 - 3, i6 + n6[0].length) : -1;
}
function parseMonthNumber(d5, string, i6) {
  var n6 = numberRe.exec(string.slice(i6, i6 + 2));
  return n6 ? (d5.m = n6[0] - 1, i6 + n6[0].length) : -1;
}
function parseDayOfMonth(d5, string, i6) {
  var n6 = numberRe.exec(string.slice(i6, i6 + 2));
  return n6 ? (d5.d = +n6[0], i6 + n6[0].length) : -1;
}
function parseDayOfYear(d5, string, i6) {
  var n6 = numberRe.exec(string.slice(i6, i6 + 3));
  return n6 ? (d5.m = 0, d5.d = +n6[0], i6 + n6[0].length) : -1;
}
function parseHour24(d5, string, i6) {
  var n6 = numberRe.exec(string.slice(i6, i6 + 2));
  return n6 ? (d5.H = +n6[0], i6 + n6[0].length) : -1;
}
function parseMinutes(d5, string, i6) {
  var n6 = numberRe.exec(string.slice(i6, i6 + 2));
  return n6 ? (d5.M = +n6[0], i6 + n6[0].length) : -1;
}
function parseSeconds(d5, string, i6) {
  var n6 = numberRe.exec(string.slice(i6, i6 + 2));
  return n6 ? (d5.S = +n6[0], i6 + n6[0].length) : -1;
}
function parseMilliseconds(d5, string, i6) {
  var n6 = numberRe.exec(string.slice(i6, i6 + 3));
  return n6 ? (d5.L = +n6[0], i6 + n6[0].length) : -1;
}
function parseMicroseconds(d5, string, i6) {
  var n6 = numberRe.exec(string.slice(i6, i6 + 6));
  return n6 ? (d5.L = Math.floor(n6[0] / 1e3), i6 + n6[0].length) : -1;
}
function parseLiteralPercent(d5, string, i6) {
  var n6 = percentRe.exec(string.slice(i6, i6 + 1));
  return n6 ? i6 + n6[0].length : -1;
}
function parseUnixTimestamp(d5, string, i6) {
  var n6 = numberRe.exec(string.slice(i6));
  return n6 ? (d5.Q = +n6[0], i6 + n6[0].length) : -1;
}
function parseUnixTimestampSeconds(d5, string, i6) {
  var n6 = numberRe.exec(string.slice(i6));
  return n6 ? (d5.s = +n6[0], i6 + n6[0].length) : -1;
}
function formatDayOfMonth(d5, p4) {
  return pad(d5.getDate(), p4, 2);
}
function formatHour24(d5, p4) {
  return pad(d5.getHours(), p4, 2);
}
function formatHour12(d5, p4) {
  return pad(d5.getHours() % 12 || 12, p4, 2);
}
function formatDayOfYear(d5, p4) {
  return pad(1 + day_default.count(year_default(d5), d5), p4, 3);
}
function formatMilliseconds(d5, p4) {
  return pad(d5.getMilliseconds(), p4, 3);
}
function formatMicroseconds(d5, p4) {
  return formatMilliseconds(d5, p4) + "000";
}
function formatMonthNumber(d5, p4) {
  return pad(d5.getMonth() + 1, p4, 2);
}
function formatMinutes(d5, p4) {
  return pad(d5.getMinutes(), p4, 2);
}
function formatSeconds(d5, p4) {
  return pad(d5.getSeconds(), p4, 2);
}
function formatWeekdayNumberMonday(d5) {
  var day2 = d5.getDay();
  return day2 === 0 ? 7 : day2;
}
function formatWeekNumberSunday(d5, p4) {
  return pad(sunday.count(year_default(d5) - 1, d5), p4, 2);
}
function dISO(d5) {
  var day2 = d5.getDay();
  return day2 >= 4 || day2 === 0 ? thursday(d5) : thursday.ceil(d5);
}
function formatWeekNumberISO(d5, p4) {
  d5 = dISO(d5);
  return pad(thursday.count(year_default(d5), d5) + (year_default(d5).getDay() === 4), p4, 2);
}
function formatWeekdayNumberSunday(d5) {
  return d5.getDay();
}
function formatWeekNumberMonday(d5, p4) {
  return pad(monday.count(year_default(d5) - 1, d5), p4, 2);
}
function formatYear(d5, p4) {
  return pad(d5.getFullYear() % 100, p4, 2);
}
function formatYearISO(d5, p4) {
  d5 = dISO(d5);
  return pad(d5.getFullYear() % 100, p4, 2);
}
function formatFullYear(d5, p4) {
  return pad(d5.getFullYear() % 1e4, p4, 4);
}
function formatFullYearISO(d5, p4) {
  var day2 = d5.getDay();
  d5 = day2 >= 4 || day2 === 0 ? thursday(d5) : thursday.ceil(d5);
  return pad(d5.getFullYear() % 1e4, p4, 4);
}
function formatZone(d5) {
  var z5 = d5.getTimezoneOffset();
  return (z5 > 0 ? "-" : (z5 *= -1, "+")) + pad(z5 / 60 | 0, "0", 2) + pad(z5 % 60, "0", 2);
}
function formatUTCDayOfMonth(d5, p4) {
  return pad(d5.getUTCDate(), p4, 2);
}
function formatUTCHour24(d5, p4) {
  return pad(d5.getUTCHours(), p4, 2);
}
function formatUTCHour12(d5, p4) {
  return pad(d5.getUTCHours() % 12 || 12, p4, 2);
}
function formatUTCDayOfYear(d5, p4) {
  return pad(1 + utcDay_default.count(utcYear_default(d5), d5), p4, 3);
}
function formatUTCMilliseconds(d5, p4) {
  return pad(d5.getUTCMilliseconds(), p4, 3);
}
function formatUTCMicroseconds(d5, p4) {
  return formatUTCMilliseconds(d5, p4) + "000";
}
function formatUTCMonthNumber(d5, p4) {
  return pad(d5.getUTCMonth() + 1, p4, 2);
}
function formatUTCMinutes(d5, p4) {
  return pad(d5.getUTCMinutes(), p4, 2);
}
function formatUTCSeconds(d5, p4) {
  return pad(d5.getUTCSeconds(), p4, 2);
}
function formatUTCWeekdayNumberMonday(d5) {
  var dow = d5.getUTCDay();
  return dow === 0 ? 7 : dow;
}
function formatUTCWeekNumberSunday(d5, p4) {
  return pad(utcSunday.count(utcYear_default(d5) - 1, d5), p4, 2);
}
function UTCdISO(d5) {
  var day2 = d5.getUTCDay();
  return day2 >= 4 || day2 === 0 ? utcThursday(d5) : utcThursday.ceil(d5);
}
function formatUTCWeekNumberISO(d5, p4) {
  d5 = UTCdISO(d5);
  return pad(utcThursday.count(utcYear_default(d5), d5) + (utcYear_default(d5).getUTCDay() === 4), p4, 2);
}
function formatUTCWeekdayNumberSunday(d5) {
  return d5.getUTCDay();
}
function formatUTCWeekNumberMonday(d5, p4) {
  return pad(utcMonday.count(utcYear_default(d5) - 1, d5), p4, 2);
}
function formatUTCYear(d5, p4) {
  return pad(d5.getUTCFullYear() % 100, p4, 2);
}
function formatUTCYearISO(d5, p4) {
  d5 = UTCdISO(d5);
  return pad(d5.getUTCFullYear() % 100, p4, 2);
}
function formatUTCFullYear(d5, p4) {
  return pad(d5.getUTCFullYear() % 1e4, p4, 4);
}
function formatUTCFullYearISO(d5, p4) {
  var day2 = d5.getUTCDay();
  d5 = day2 >= 4 || day2 === 0 ? utcThursday(d5) : utcThursday.ceil(d5);
  return pad(d5.getUTCFullYear() % 1e4, p4, 4);
}
function formatUTCZone() {
  return "+0000";
}
function formatLiteralPercent() {
  return "%";
}
function formatUnixTimestamp(d5) {
  return +d5;
}
function formatUnixTimestampSeconds(d5) {
  return Math.floor(+d5 / 1e3);
}

// node_modules/@nivo/core/node_modules/d3-time-format/src/defaultLocale.js
var locale2;
var timeFormat;
var timeParse;
var utcFormat;
var utcParse;
defaultLocale2({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function defaultLocale2(definition) {
  locale2 = formatLocale(definition);
  timeFormat = locale2.format;
  timeParse = locale2.parse;
  utcFormat = locale2.utcFormat;
  utcParse = locale2.utcParse;
  return locale2;
}

// node_modules/@nivo/core/node_modules/d3-time-format/src/isoFormat.js
var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";
function formatIsoNative(date) {
  return date.toISOString();
}
var formatIso = Date.prototype.toISOString ? formatIsoNative : utcFormat(isoSpecifier);

// node_modules/@nivo/core/node_modules/d3-time-format/src/isoParse.js
function parseIsoNative(string) {
  var date = new Date(string);
  return isNaN(date) ? null : date;
}
var parseIso = +/* @__PURE__ */ new Date("2000-01-01T00:00:00.000Z") ? parseIsoNative : utcParse(isoSpecifier);

// node_modules/@nivo/core/dist/nivo-core.mjs
var import_get2 = __toESM(require_get(), 1);
var import_isPlainObject = __toESM(require_isPlainObject(), 1);
var import_pick = __toESM(require_pick(), 1);
var import_isEqual = __toESM(require_isEqual(), 1);
var import_set3 = __toESM(require_set(), 1);
var Sr = (0, import_react19.createContext)();
var qr = function(e8) {
  var t5 = e8.children, n6 = e8.animate, o6 = void 0 === n6 || n6, i6 = e8.config, a4 = void 0 === i6 ? "default" : i6, l5 = (0, import_react19.useMemo)(function() {
    var e9 = (0, import_isString.default)(a4) ? config[a4] : a4;
    return { animate: o6, config: e9 };
  }, [o6, a4]);
  return (0, import_jsx_runtime3.jsx)(Sr.Provider, { value: l5, children: t5 });
};
var Dr = function() {
  return (0, import_react19.useContext)(Sr);
};
var Er = function(e8) {
  var r6 = e8.children, t5 = e8.condition, o6 = e8.wrapper;
  return t5 ? (0, import_react19.cloneElement)(o6, {}, r6) : r6;
};
var Ur = { position: "relative" };
var Fr = function(e8) {
  var r6 = e8.children, t5 = e8.theme, n6 = e8.renderWrapper, i6 = void 0 === n6 || n6, a4 = e8.isInteractive, l5 = void 0 === a4 || a4, d5 = e8.animate, u4 = e8.motionConfig, c8 = (0, import_react19.useRef)(null);
  return (0, import_jsx_runtime3.jsx)(z, { theme: t5, children: (0, import_jsx_runtime3.jsx)(qr, { animate: d5, config: u4, children: (0, import_jsx_runtime3.jsx)(W2, { container: c8, children: (0, import_jsx_runtime3.jsxs)(Er, { condition: i6, wrapper: (0, import_jsx_runtime3.jsx)("div", { style: Ur, ref: c8 }), children: [r6, l5 && (0, import_jsx_runtime3.jsx)(M2, {})] }) }) }) });
};
var Kr = function(e8, r6) {
  return e8.width === r6.width && e8.height === r6.height;
};
var Nr = function(e8) {
  var r6 = e8.children, t5 = e8.width, n6 = e8.height, o6 = e8.onResize, i6 = e8.debounceResize, l5 = a({ width: t5, height: n6 }, i6, { equalityFn: Kr })[0];
  return (0, import_react19.useEffect)(function() {
    null == o6 || o6(l5);
  }, [l5, o6]), (0, import_jsx_runtime3.jsx)(import_jsx_runtime3.Fragment, { children: r6(l5) });
};
var $r = function(e8) {
  var r6 = e8.children, t5 = e8.defaultWidth, n6 = e8.defaultHeight, o6 = e8.onResize, i6 = e8.debounceResize, a4 = void 0 === i6 ? 0 : i6;
  return (0, import_jsx_runtime3.jsx)(AutoSizer, { defaultWidth: t5, defaultHeight: n6, children: function(e9) {
    var t6 = e9.width, n7 = e9.height;
    return (0, import_jsx_runtime3.jsx)(Nr, { width: t6, height: n7, onResize: o6, debounceResize: a4, children: r6 });
  } });
};
function Jr(e8, r6) {
  (null == r6 || r6 > e8.length) && (r6 = e8.length);
  for (var t5 = 0, n6 = Array(r6); t5 < r6; t5++) n6[t5] = e8[t5];
  return n6;
}
function Qr(e8, r6) {
  var t5 = "undefined" != typeof Symbol && e8[Symbol.iterator] || e8["@@iterator"];
  if (t5) return (t5 = t5.call(e8)).next.bind(t5);
  if (Array.isArray(e8) || (t5 = function(e9, r7) {
    if (e9) {
      if ("string" == typeof e9) return Jr(e9, r7);
      var t6 = {}.toString.call(e9).slice(8, -1);
      return "Object" === t6 && e9.constructor && (t6 = e9.constructor.name), "Map" === t6 || "Set" === t6 ? Array.from(e9) : "Arguments" === t6 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t6) ? Jr(e9, r7) : void 0;
    }
  }(e8)) || r6 && e8 && "number" == typeof e8.length) {
    t5 && (e8 = t5);
    var n6 = 0;
    return function() {
      return n6 >= e8.length ? { done: true } : { done: false, value: e8[n6++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function Vr() {
  return Vr = Object.assign ? Object.assign.bind() : function(e8) {
    for (var r6 = 1; r6 < arguments.length; r6++) {
      var t5 = arguments[r6];
      for (var n6 in t5) ({}).hasOwnProperty.call(t5, n6) && (e8[n6] = t5[n6]);
    }
    return e8;
  }, Vr.apply(null, arguments);
}
function Zr(e8, r6) {
  if (null == e8) return {};
  var t5 = {};
  for (var n6 in e8) if ({}.hasOwnProperty.call(e8, n6)) {
    if (-1 !== r6.indexOf(n6)) continue;
    t5[n6] = e8[n6];
  }
  return t5;
}
var rt = ["id", "colors"];
var tt = function(e8) {
  var r6 = e8.id, t5 = e8.colors, n6 = Zr(e8, rt);
  return (0, import_jsx_runtime3.jsx)("linearGradient", Vr({ id: r6, x1: 0, x2: 0, y1: 0, y2: 1 }, n6, { children: t5.map(function(e9) {
    var r7 = e9.offset, t6 = e9.color, n7 = e9.opacity;
    return (0, import_jsx_runtime3.jsx)("stop", { offset: r7 + "%", stopColor: t6, stopOpacity: void 0 !== n7 ? n7 : 1 }, r7);
  }) }));
};
var ot = { linearGradient: tt };
var it = { color: "#000000", background: "#ffffff", size: 4, padding: 4, stagger: false };
var at = (0, import_react19.memo)(function(e8) {
  var r6 = e8.id, t5 = e8.background, n6 = void 0 === t5 ? it.background : t5, o6 = e8.color, i6 = void 0 === o6 ? it.color : o6, a4 = e8.size, l5 = void 0 === a4 ? it.size : a4, d5 = e8.padding, u4 = void 0 === d5 ? it.padding : d5, c8 = e8.stagger, s5 = void 0 === c8 ? it.stagger : c8, f3 = l5 + u4, h2 = l5 / 2, p4 = u4 / 2;
  return true === s5 && (f3 = 2 * l5 + 2 * u4), (0, import_jsx_runtime3.jsxs)("pattern", { id: r6, width: f3, height: f3, patternUnits: "userSpaceOnUse", children: [(0, import_jsx_runtime3.jsx)("rect", { width: f3, height: f3, fill: n6 }), (0, import_jsx_runtime3.jsx)("circle", { cx: p4 + h2, cy: p4 + h2, r: h2, fill: i6 }), s5 && (0, import_jsx_runtime3.jsx)("circle", { cx: 1.5 * u4 + l5 + h2, cy: 1.5 * u4 + l5 + h2, r: h2, fill: i6 })] });
});
var dt = 2 * Math.PI;
var ut = function(e8) {
  return e8 * Math.PI / 180;
};
var ct = function(e8) {
  return 180 * e8 / Math.PI;
};
var st = function(e8) {
  return e8.startAngle + (e8.endAngle - e8.startAngle) / 2;
};
var ft = function(e8, r6) {
  return { x: Math.cos(e8) * r6, y: Math.sin(e8) * r6 };
};
var mt = { spacing: 5, rotation: 0, background: "#000000", color: "#ffffff", lineWidth: 2 };
var vt = (0, import_react19.memo)(function(e8) {
  var r6 = e8.id, t5 = e8.spacing, n6 = void 0 === t5 ? mt.spacing : t5, o6 = e8.rotation, i6 = void 0 === o6 ? mt.rotation : o6, a4 = e8.background, l5 = void 0 === a4 ? mt.background : a4, d5 = e8.color, u4 = void 0 === d5 ? mt.color : d5, c8 = e8.lineWidth, s5 = void 0 === c8 ? mt.lineWidth : c8, f3 = Math.round(i6) % 360, h2 = Math.abs(n6);
  f3 > 180 ? f3 -= 360 : f3 > 90 ? f3 -= 180 : f3 < -180 ? f3 += 360 : f3 < -90 && (f3 += 180);
  var p4, g2 = h2, b5 = h2;
  return 0 === f3 ? p4 = "\n                M 0 0 L " + g2 + " 0\n                M 0 " + b5 + " L " + g2 + " " + b5 + "\n            " : 90 === f3 ? p4 = "\n                M 0 0 L 0 " + b5 + "\n                M " + g2 + " 0 L " + g2 + " " + b5 + "\n            " : (g2 = Math.abs(h2 / Math.sin(ut(f3))), b5 = h2 / Math.sin(ut(90 - f3)), p4 = f3 > 0 ? "\n                    M 0 " + -b5 + " L " + 2 * g2 + " " + b5 + "\n                    M " + -g2 + " " + -b5 + " L " + g2 + " " + b5 + "\n                    M " + -g2 + " 0 L " + g2 + " " + 2 * b5 + "\n                " : "\n                    M " + -g2 + " " + b5 + " L " + g2 + " " + -b5 + "\n                    M " + -g2 + " " + 2 * b5 + " L " + 2 * g2 + " " + -b5 + "\n                    M 0 " + 2 * b5 + " L " + 2 * g2 + " 0\n                "), (0, import_jsx_runtime3.jsxs)("pattern", { id: r6, width: g2, height: b5, patternUnits: "userSpaceOnUse", children: [(0, import_jsx_runtime3.jsx)("rect", { width: g2, height: b5, fill: l5, stroke: "rgba(255, 0, 0, 0.1)", strokeWidth: 0 }), (0, import_jsx_runtime3.jsx)("path", { d: p4, strokeWidth: s5, stroke: u4, strokeLinecap: "square" })] });
});
var _t = { color: "#000000", background: "#ffffff", size: 4, padding: 4, stagger: false };
var wt = (0, import_react19.memo)(function(e8) {
  var r6 = e8.id, t5 = e8.color, n6 = void 0 === t5 ? _t.color : t5, o6 = e8.background, i6 = void 0 === o6 ? _t.background : o6, a4 = e8.size, l5 = void 0 === a4 ? _t.size : a4, d5 = e8.padding, u4 = void 0 === d5 ? _t.padding : d5, c8 = e8.stagger, s5 = void 0 === c8 ? _t.stagger : c8, f3 = l5 + u4, h2 = u4 / 2;
  return true === s5 && (f3 = 2 * l5 + 2 * u4), (0, import_jsx_runtime3.jsxs)("pattern", { id: r6, width: f3, height: f3, patternUnits: "userSpaceOnUse", children: [(0, import_jsx_runtime3.jsx)("rect", { width: f3, height: f3, fill: i6 }), (0, import_jsx_runtime3.jsx)("rect", { x: h2, y: h2, width: l5, height: l5, fill: n6 }), s5 && (0, import_jsx_runtime3.jsx)("rect", { x: 1.5 * u4 + l5, y: 1.5 * u4 + l5, width: l5, height: l5, fill: n6 })] });
});
var xt = { patternDots: at, patternLines: vt, patternSquares: wt };
var Ot = ["type"];
var zt = Vr({}, ot, xt);
var Mt = (0, import_react19.memo)(function(e8) {
  var r6 = e8.defs;
  return !r6 || r6.length < 1 ? null : (0, import_jsx_runtime3.jsx)("defs", { "aria-hidden": true, children: r6.map(function(e9) {
    var r7 = e9.type, t5 = Zr(e9, Ot);
    return zt[r7] ? (0, import_react19.createElement)(zt[r7], Vr({ key: t5.id }, t5)) : null;
  }) });
});
var Rt = (0, import_react19.forwardRef)(function(e8, r6) {
  var t5 = e8.width, n6 = e8.height, o6 = e8.margin, i6 = e8.defs, a4 = e8.children, l5 = e8.role, d5 = e8.ariaLabel, u4 = e8.ariaLabelledBy, c8 = e8.ariaDescribedBy, s5 = e8.isFocusable, f3 = M();
  return (0, import_jsx_runtime3.jsxs)("svg", { xmlns: "http://www.w3.org/2000/svg", width: t5, height: n6, role: l5, "aria-label": d5, "aria-labelledby": u4, "aria-describedby": c8, focusable: s5, tabIndex: s5 ? 0 : void 0, ref: r6, children: [(0, import_jsx_runtime3.jsx)(Mt, { defs: i6 }), (0, import_jsx_runtime3.jsx)("rect", { width: t5, height: n6, fill: f3.background }), (0, import_jsx_runtime3.jsx)("g", { transform: "translate(" + o6.left + "," + o6.top + ")", children: a4 })] });
});
var jt = (0, import_react19.memo)(function(e8) {
  var r6 = e8.size, t5 = e8.color, n6 = e8.borderWidth, o6 = e8.borderColor;
  return (0, import_jsx_runtime3.jsx)("circle", { r: r6 / 2, fill: t5, stroke: o6, strokeWidth: n6, style: { pointerEvents: "none" } });
});
var Ct = (0, import_react19.memo)(function(e8) {
  var r6 = e8.x, t5 = e8.y, n6 = e8.symbol, o6 = void 0 === n6 ? jt : n6, a4 = e8.size, l5 = e8.datum, u4 = e8.color, c8 = e8.borderWidth, s5 = e8.borderColor, f3 = e8.label, h2 = e8.labelTextAnchor, p4 = void 0 === h2 ? "middle" : h2, g2 = e8.labelYOffset, b5 = void 0 === g2 ? -12 : g2, m3 = e8.ariaLabel, _2 = e8.ariaLabelledBy, w4 = e8.ariaDescribedBy, O4 = e8.ariaHidden, R2 = e8.ariaDisabled, j4 = e8.isFocusable, C4 = void 0 !== j4 && j4, B2 = e8.tabIndex, P5 = void 0 === B2 ? 0 : B2, W5 = e8.onFocus, G2 = e8.onBlur, I2 = e8.testId, A3 = M(), L4 = Dr(), S3 = L4.animate, Y = L4.config, q2 = useSpring({ transform: "translate(" + r6 + ", " + t5 + ")", config: Y, immediate: !S3 }), D = (0, import_react19.useCallback)(function(e9) {
    null == W5 || W5(l5, e9);
  }, [W5, l5]), E2 = (0, import_react19.useCallback)(function(e9) {
    null == G2 || G2(l5, e9);
  }, [G2, l5]);
  return (0, import_jsx_runtime3.jsxs)(animated.g, { transform: q2.transform, style: { pointerEvents: "none" }, focusable: C4, tabIndex: C4 ? P5 : void 0, "aria-label": m3, "aria-labelledby": _2, "aria-describedby": w4, "aria-disabled": R2, "aria-hidden": O4, onFocus: C4 && W5 ? D : void 0, onBlur: C4 && G2 ? E2 : void 0, "data-testid": I2, children: [(0, import_react19.createElement)(o6, { size: a4, color: u4, datum: l5, borderWidth: c8, borderColor: s5 }), f3 && (0, import_jsx_runtime3.jsx)("text", { textAnchor: p4, y: b5, style: b(A3.dots.text), children: f3 })] });
});
var Bt = (0, import_react19.memo)(function(e8) {
  var r6 = e8.width, t5 = e8.height, n6 = e8.axis, o6 = e8.scale, i6 = e8.value, a4 = e8.lineStyle, l5 = e8.textStyle, d5 = e8.legend, u4 = e8.legendNode, c8 = e8.legendPosition, s5 = void 0 === c8 ? "top-right" : c8, f3 = e8.legendOffsetX, h2 = void 0 === f3 ? 14 : f3, p4 = e8.legendOffsetY, g2 = void 0 === p4 ? 14 : p4, b5 = e8.legendOrientation, m3 = void 0 === b5 ? "horizontal" : b5, y3 = M(), _2 = 0, w4 = 0, k3 = 0, x3 = 0;
  if ("y" === n6 ? (k3 = o6(i6), w4 = r6) : (_2 = o6(i6), x3 = t5), d5 && !u4) {
    var O4 = function(e9) {
      var r7 = e9.axis, t6 = e9.width, n7 = e9.height, o7 = e9.position, i7 = e9.offsetX, a5 = e9.offsetY, l6 = e9.orientation, d6 = 0, u5 = 0, c9 = "vertical" === l6 ? -90 : 0, s6 = "start";
      if ("x" === r7) switch (o7) {
        case "top-left":
          d6 = -i7, u5 = a5, s6 = "end";
          break;
        case "top":
          u5 = -a5, s6 = "horizontal" === l6 ? "middle" : "start";
          break;
        case "top-right":
          d6 = i7, u5 = a5, s6 = "horizontal" === l6 ? "start" : "end";
          break;
        case "right":
          d6 = i7, u5 = n7 / 2, s6 = "horizontal" === l6 ? "start" : "middle";
          break;
        case "bottom-right":
          d6 = i7, u5 = n7 - a5, s6 = "start";
          break;
        case "bottom":
          u5 = n7 + a5, s6 = "horizontal" === l6 ? "middle" : "end";
          break;
        case "bottom-left":
          u5 = n7 - a5, d6 = -i7, s6 = "horizontal" === l6 ? "end" : "start";
          break;
        case "left":
          d6 = -i7, u5 = n7 / 2, s6 = "horizontal" === l6 ? "end" : "middle";
      }
      else switch (o7) {
        case "top-left":
          d6 = i7, u5 = -a5, s6 = "start";
          break;
        case "top":
          d6 = t6 / 2, u5 = -a5, s6 = "horizontal" === l6 ? "middle" : "start";
          break;
        case "top-right":
          d6 = t6 - i7, u5 = -a5, s6 = "horizontal" === l6 ? "end" : "start";
          break;
        case "right":
          d6 = t6 + i7, s6 = "horizontal" === l6 ? "start" : "middle";
          break;
        case "bottom-right":
          d6 = t6 - i7, u5 = a5, s6 = "end";
          break;
        case "bottom":
          d6 = t6 / 2, u5 = a5, s6 = "horizontal" === l6 ? "middle" : "end";
          break;
        case "bottom-left":
          d6 = i7, u5 = a5, s6 = "horizontal" === l6 ? "start" : "end";
          break;
        case "left":
          d6 = -i7, s6 = "horizontal" === l6 ? "end" : "middle";
      }
      return { x: d6, y: u5, rotation: c9, textAnchor: s6 };
    }({ axis: n6, width: r6, height: t5, position: s5, offsetX: h2, offsetY: g2, orientation: m3 });
    u4 = (0, import_jsx_runtime3.jsx)("text", { transform: "translate(" + O4.x + ", " + O4.y + ") rotate(" + O4.rotation + ")", textAnchor: O4.textAnchor, dominantBaseline: "central", style: l5, children: d5 });
  }
  return (0, import_jsx_runtime3.jsxs)("g", { transform: "translate(" + _2 + ", " + k3 + ")", children: [(0, import_jsx_runtime3.jsx)("line", { x1: 0, x2: w4, y1: 0, y2: x3, stroke: y3.markers.lineColor, strokeWidth: y3.markers.lineStrokeWidth, style: a4 }), u4] });
});
var Pt = (0, import_react19.memo)(function(e8) {
  var r6 = e8.markers, t5 = e8.width, n6 = e8.height, o6 = e8.xScale, i6 = e8.yScale;
  return r6 && 0 !== r6.length ? r6.map(function(e9, r7) {
    return (0, import_jsx_runtime3.jsx)(Bt, Vr({}, e9, { width: t5, height: n6, scale: "y" === e9.axis ? i6 : o6 }), r7);
  }) : null;
});
var At = (0, import_react19.createContext)(void 0);
var Lt = { basis: basis_default, basisClosed: basisClosed_default, basisOpen: basisOpen_default, bundle: bundle_default, cardinal: cardinal_default, cardinalClosed: cardinalClosed_default, cardinalOpen: cardinalOpen_default, catmullRom: catmullRom_default, catmullRomClosed: catmullRomClosed_default, catmullRomOpen: catmullRomOpen_default, linear: linear_default, linearClosed: linearClosed_default, monotoneX, monotoneY, natural: natural_default, step: step_default, stepAfter, stepBefore };
var St = Object.keys(Lt);
var Yt = St.filter(function(e8) {
  return e8.endsWith("Closed");
});
var qt = (0, import_without.default)(St, "bundle", "basisClosed", "basisOpen", "cardinalClosed", "cardinalOpen", "catmullRomClosed", "catmullRomOpen", "linearClosed");
var Dt = (0, import_without.default)(St, "bundle", "basisClosed", "basisOpen", "cardinalClosed", "cardinalOpen", "catmullRomClosed", "catmullRomOpen", "linearClosed");
var Ut = { ascending: ascending_default, descending: descending_default, insideOut: insideOut_default, none: none_default2, reverse: reverse_default };
var Ft = Object.keys(Ut);
var Ht = { expand: expand_default, diverging: diverging_default, none: none_default, silhouette: silhouette_default, wiggle: wiggle_default };
var Xt = Object.keys(Ht);
var Jt = { nivo: ["#d76445", "#f47560", "#e8c1a0", "#97e3d5", "#61cdbb", "#00b0a7"], BrBG: (0, import_last.default)(scheme), PRGn: (0, import_last.default)(scheme2), PiYG: (0, import_last.default)(scheme3), PuOr: (0, import_last.default)(scheme4), RdBu: (0, import_last.default)(scheme5), RdGy: (0, import_last.default)(scheme6), RdYlBu: (0, import_last.default)(scheme7), RdYlGn: (0, import_last.default)(scheme8), spectral: (0, import_last.default)(scheme9), blues: (0, import_last.default)(scheme22), greens: (0, import_last.default)(scheme23), greys: (0, import_last.default)(scheme24), oranges: (0, import_last.default)(scheme27), purples: (0, import_last.default)(scheme25), reds: (0, import_last.default)(scheme26), BuGn: (0, import_last.default)(scheme10), BuPu: (0, import_last.default)(scheme11), GnBu: (0, import_last.default)(scheme12), OrRd: (0, import_last.default)(scheme13), PuBuGn: (0, import_last.default)(scheme14), PuBu: (0, import_last.default)(scheme15), PuRd: (0, import_last.default)(scheme16), RdPu: (0, import_last.default)(scheme17), YlGnBu: (0, import_last.default)(scheme18), YlGn: (0, import_last.default)(scheme19), YlOrBr: (0, import_last.default)(scheme20), YlOrRd: (0, import_last.default)(scheme21) };
var Qt = Object.keys(Jt);
var Zt = { nivo: ["#e8c1a0", "#f47560", "#f1e15b", "#e8a838", "#61cdbb", "#97e3d5"], category10: category10_default, accent: Accent_default, dark2: Dark2_default, paired: Paired_default, pastel1: Pastel1_default, pastel2: Pastel2_default, set1: Set1_default, set2: Set2_default, set3: Set3_default, brown_blueGreen: (0, import_last.default)(scheme), purpleRed_green: (0, import_last.default)(scheme2), pink_yellowGreen: (0, import_last.default)(scheme3), purple_orange: (0, import_last.default)(scheme4), red_blue: (0, import_last.default)(scheme5), red_grey: (0, import_last.default)(scheme6), red_yellow_blue: (0, import_last.default)(scheme7), red_yellow_green: (0, import_last.default)(scheme8), spectral: (0, import_last.default)(scheme9), blues: (0, import_last.default)(scheme22), greens: (0, import_last.default)(scheme23), greys: (0, import_last.default)(scheme24), oranges: (0, import_last.default)(scheme27), purples: (0, import_last.default)(scheme25), reds: (0, import_last.default)(scheme26), blue_green: (0, import_last.default)(scheme10), blue_purple: (0, import_last.default)(scheme11), green_blue: (0, import_last.default)(scheme12), orange_red: (0, import_last.default)(scheme13), purple_blue_green: (0, import_last.default)(scheme14), purple_blue: (0, import_last.default)(scheme15), purple_red: (0, import_last.default)(scheme16), red_purple: (0, import_last.default)(scheme17), yellow_green_blue: (0, import_last.default)(scheme18), yellow_green: (0, import_last.default)(scheme19), yellow_orange_brown: (0, import_last.default)(scheme20), yellow_orange_red: (0, import_last.default)(scheme21) };
var dn = ordinal(Set3_default);
var un = { top: 0, right: 0, bottom: 0, left: 0 };
var cn = function(e8, t5, n6) {
  return void 0 === n6 && (n6 = {}), (0, import_react19.useMemo)(function() {
    var r6 = Vr({}, un, n6);
    return { margin: r6, innerWidth: e8 - r6.left - r6.right, innerHeight: t5 - r6.top - r6.bottom, outerWidth: e8, outerHeight: t5 };
  }, [e8, t5, n6]);
};
var sn = function() {
  var e8 = (0, import_react19.useRef)(null), r6 = (0, import_react19.useState)({ left: 0, top: 0, width: 0, height: 0 }), t5 = r6[0], n6 = r6[1], i6 = (0, import_react19.useState)(function() {
    return "undefined" == typeof ResizeObserver ? null : new ResizeObserver(function(e9) {
      var r7 = e9[0];
      return n6(r7.contentRect);
    });
  })[0];
  return (0, import_react19.useEffect)(function() {
    return e8.current && null !== i6 && i6.observe(e8.current), function() {
      null !== i6 && i6.disconnect();
    };
  }, [i6]), [e8, t5];
};
var fn = function(e8) {
  return "function" == typeof e8 ? e8 : "string" == typeof e8 ? 0 === e8.indexOf("time:") ? timeFormat(e8.slice("5")) : format(e8) : function(e9) {
    return "" + e9;
  };
};
var hn = function(e8) {
  return (0, import_react19.useMemo)(function() {
    return fn(e8);
  }, [e8]);
};
var gn = function(e8) {
  return (0, import_isFunction.default)(e8) ? e8 : function(r6) {
    return (0, import_get2.default)(r6, e8);
  };
};
var bn = function(e8) {
  return (0, import_react19.useMemo)(function() {
    return gn(e8);
  }, [e8]);
};
var xn = Object.keys(ot);
var On = Object.keys(xt);
var zn = function(e8, r6, t5) {
  if ("*" === e8) return true;
  if ((0, import_isFunction.default)(e8)) return e8(r6);
  if ((0, import_isPlainObject.default)(e8)) {
    var n6 = t5 ? (0, import_get2.default)(r6, t5) : r6;
    return (0, import_isEqual.default)((0, import_pick.default)(n6, Object.keys(e8)), e8);
  }
  return false;
};
var Mn = function(e8, r6, t5, n6) {
  var o6 = void 0 === n6 ? {} : n6, i6 = o6.dataKey, a4 = o6.colorKey, l5 = void 0 === a4 ? "color" : a4, d5 = o6.targetKey, u4 = void 0 === d5 ? "fill" : d5, c8 = [], s5 = {};
  return e8.length && r6.length && (c8 = [].concat(e8), r6.forEach(function(r7) {
    for (var n7, o7 = function() {
      var t6 = n7.value, o8 = t6.id, a6 = t6.match;
      if (zn(a6, r7, i6)) {
        var d6 = e8.find(function(e9) {
          return e9.id === o8;
        });
        if (d6) {
          if (On.includes(d6.type)) if ("inherit" === d6.background || "inherit" === d6.color) {
            var f3 = (0, import_get2.default)(r7, l5), h2 = d6.background, p4 = d6.color, g2 = o8;
            "inherit" === d6.background && (g2 = g2 + ".bg." + f3, h2 = f3), "inherit" === d6.color && (g2 = g2 + ".fg." + f3, p4 = f3), (0, import_set3.default)(r7, u4, "url(#" + g2 + ")"), s5[g2] || (c8.push(Vr({}, d6, { id: g2, background: h2, color: p4 })), s5[g2] = 1);
          } else (0, import_set3.default)(r7, u4, "url(#" + o8 + ")");
          else if (xn.includes(d6.type)) {
            if (d6.colors.map(function(e9) {
              return e9.color;
            }).includes("inherit")) {
              var b5 = (0, import_get2.default)(r7, l5), m3 = o8, v2 = Vr({}, d6, { colors: d6.colors.map(function(e9, r8) {
                return "inherit" !== e9.color ? e9 : (m3 = m3 + "." + r8 + "." + b5, Vr({}, e9, { color: "inherit" === e9.color ? b5 : e9.color }));
              }) });
              v2.id = m3, (0, import_set3.default)(r7, u4, "url(#" + m3 + ")"), s5[m3] || (c8.push(v2), s5[m3] = 1);
            } else (0, import_set3.default)(r7, u4, "url(#" + o8 + ")");
          }
        }
        return 1;
      }
    }, a5 = Qr(t5); !(n7 = a5()).done && !o7(); ) ;
  })), c8;
};

// node_modules/@nivo/text/dist/nivo-text.mjs
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
function p2() {
  return p2 = Object.assign ? Object.assign.bind() : function(t5) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var o6 = arguments[e8];
      for (var n6 in o6) ({}).hasOwnProperty.call(o6, n6) && (t5[n6] = o6[n6]);
    }
    return t5;
  }, p2.apply(null, arguments);
}
function s3(t5, e8) {
  if (null == t5) return {};
  var o6 = {};
  for (var n6 in t5) if ({}.hasOwnProperty.call(t5, n6)) {
    if (-1 !== e8.indexOf(n6)) continue;
    o6[n6] = t5[n6];
  }
  return o6;
}
var h = ["style", "children"];
var m2 = ["outlineWidth", "outlineColor", "outlineOpacity"];
var b3 = function(r6) {
  var i6 = r6.style, l5 = r6.children, c8 = s3(r6, h), f3 = i6.outlineWidth, u4 = i6.outlineColor, a4 = i6.outlineOpacity, d5 = s3(i6, m2);
  return (0, import_jsx_runtime4.jsxs)(import_jsx_runtime4.Fragment, { children: [f3 > 0 && (0, import_jsx_runtime4.jsx)(animated.text, p2({}, c8, { style: p2({}, d5, { strokeWidth: 2 * f3, stroke: u4, strokeOpacity: a4, strokeLinejoin: "round" }), children: l5 })), (0, import_jsx_runtime4.jsx)(animated.text, p2({}, c8, { style: d5, children: l5 }))] });
};

// node_modules/@nivo/arcs/dist/nivo-arcs.mjs
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var import_react21 = __toESM(require_react(), 1);

// node_modules/@nivo/colors/dist/nivo-colors.mjs
init_src5();
var import_react20 = __toESM(require_react(), 1);
var import_get3 = __toESM(require_get(), 1);
var import_isPlainObject2 = __toESM(require_isPlainObject(), 1);
init_src();
init_src4();
function Se(e8, r6) {
  (null == r6 || r6 > e8.length) && (r6 = e8.length);
  for (var n6 = 0, t5 = Array(r6); n6 < r6; n6++) t5[n6] = e8[n6];
  return t5;
}
function qe(e8, r6) {
  var n6 = "undefined" != typeof Symbol && e8[Symbol.iterator] || e8["@@iterator"];
  if (n6) return (n6 = n6.call(e8)).next.bind(n6);
  if (Array.isArray(e8) || (n6 = function(e9, r7) {
    if (e9) {
      if ("string" == typeof e9) return Se(e9, r7);
      var n7 = {}.toString.call(e9).slice(8, -1);
      return "Object" === n7 && e9.constructor && (n7 = e9.constructor.name), "Map" === n7 || "Set" === n7 ? Array.from(e9) : "Arguments" === n7 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n7) ? Se(e9, r7) : void 0;
    }
  }(e8)) || r6 && e8 && "number" == typeof e8.length) {
    n6 && (e8 = n6);
    var t5 = 0;
    return function() {
      return t5 >= e8.length ? { done: true } : { done: false, value: e8[t5++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function Ce() {
  return Ce = Object.assign ? Object.assign.bind() : function(e8) {
    for (var r6 = 1; r6 < arguments.length; r6++) {
      var n6 = arguments[r6];
      for (var t5 in n6) ({}).hasOwnProperty.call(n6, t5) && (e8[t5] = n6[t5]);
    }
    return e8;
  }, Ce.apply(null, arguments);
}
var Ge = { nivo: ["#e8c1a0", "#f47560", "#f1e15b", "#e8a838", "#61cdbb", "#97e3d5"], category10: category10_default, accent: Accent_default, dark2: Dark2_default, paired: Paired_default, pastel1: Pastel1_default, pastel2: Pastel2_default, set1: Set1_default, set2: Set2_default, set3: Set3_default, tableau10: Tableau10_default };
var Ve = Object.keys(Ge);
var Pe = { brown_blueGreen: scheme, purpleRed_green: scheme2, pink_yellowGreen: scheme3, purple_orange: scheme4, red_blue: scheme5, red_grey: scheme6, red_yellow_blue: scheme7, red_yellow_green: scheme8, spectral: scheme9 };
var Re = Object.keys(Pe);
var Ue = { brown_blueGreen: BrBG_default, purpleRed_green: PRGn_default, pink_yellowGreen: PiYG_default, purple_orange: PuOr_default, red_blue: RdBu_default, red_grey: RdGy_default, red_yellow_blue: RdYlBu_default, red_yellow_green: RdYlGn_default, spectral: Spectral_default };
var De = { blues: scheme22, greens: scheme23, greys: scheme24, oranges: scheme27, purples: scheme25, reds: scheme26, blue_green: scheme10, blue_purple: scheme11, green_blue: scheme12, orange_red: scheme13, purple_blue_green: scheme14, purple_blue: scheme15, purple_red: scheme16, red_purple: scheme17, yellow_green_blue: scheme18, yellow_green: scheme19, yellow_orange_brown: scheme20, yellow_orange_red: scheme21 };
var Me = Object.keys(De);
var Te = { blues: Blues_default, greens: Greens_default, greys: Greys_default, oranges: Oranges_default, purples: Purples_default, reds: Reds_default, turbo: turbo_default, viridis: viridis_default, inferno, magma, plasma, cividis: cividis_default, warm, cool, cubehelixDefault: cubehelix_default, blue_green: BuGn_default, blue_purple: BuPu_default, green_blue: GnBu_default, orange_red: OrRd_default, purple_blue_green: PuBuGn_default, purple_blue: PuBu_default, purple_red: PuRd_default, red_purple: RdPu_default, yellow_green_blue: YlGnBu_default, yellow_green: YlGn_default, yellow_orange_brown: YlOrBr_default, yellow_orange_red: YlOrRd_default };
var $e = Ce({}, Ge, Pe, De);
var Be = Object.keys($e);
var Fe = function(e8) {
  return Ve.includes(e8);
};
var He = function(e8) {
  return Re.includes(e8);
};
var Je = function(e8) {
  return Me.includes(e8);
};
var Ke = { rainbow: rainbow_default, sinebow: sinebow_default };
var Le = Ce({}, Ue, Te, Ke);
var Ne = Object.keys(Le);
var Qe = function(e8) {
  return void 0 !== e8.theme;
};
var We = function(e8) {
  return void 0 !== e8.from;
};
var Xe = function(e8, r6) {
  if ("function" == typeof e8) return e8;
  if ((0, import_isPlainObject2.default)(e8)) {
    if (Qe(e8)) {
      if (void 0 === r6) throw new Error("Unable to use color from theme as no theme was provided");
      var n6 = (0, import_get3.default)(r6, e8.theme);
      if (void 0 === n6) throw new Error("Color from theme is undefined at path: '" + e8.theme + "'");
      return function() {
        return n6;
      };
    }
    if (We(e8)) {
      var t5 = function(r7) {
        return (0, import_get3.default)(r7, e8.from);
      };
      if (Array.isArray(e8.modifiers)) {
        for (var o6, i6 = [], u4 = function() {
          var e9 = o6.value, r7 = e9[0], n7 = e9[1];
          if ("brighter" === r7) i6.push(function(e11) {
            return e11.brighter(n7);
          });
          else if ("darker" === r7) i6.push(function(e11) {
            return e11.darker(n7);
          });
          else {
            if ("opacity" !== r7) throw new Error("Invalid color modifier: '" + r7 + "', must be one of: 'brighter', 'darker', 'opacity'");
            i6.push(function(e11) {
              return e11.opacity = n7, e11;
            });
          }
        }, l5 = qe(e8.modifiers); !(o6 = l5()).done; ) u4();
        return 0 === i6.length ? t5 : function(e9) {
          return i6.reduce(function(e11, r7) {
            return r7(e11);
          }, rgb(t5(e9))).toString();
        };
      }
      return t5;
    }
    throw new Error("Invalid color spec, you should either specify 'theme' or 'from' when using a config object");
  }
  return function() {
    return e8;
  };
};
var Ye = function(e8, r6) {
  return (0, import_react20.useMemo)(function() {
    return Xe(e8, r6);
  }, [e8, r6]);
};
var gr = function(e8, r6) {
  if ("function" == typeof e8) return e8;
  var n6 = "function" == typeof r6 ? r6 : function(e9) {
    return (0, import_get3.default)(e9, r6);
  };
  if (Array.isArray(e8)) {
    var t5 = ordinal(e8), o6 = function(e9) {
      return t5(n6(e9));
    };
    return o6.scale = t5, o6;
  }
  if ((0, import_isPlainObject2.default)(e8)) {
    if (function(e9) {
      return void 0 !== e9.datum;
    }(e8)) return function(r7) {
      return (0, import_get3.default)(r7, e8.datum);
    };
    if (function(e9) {
      return void 0 !== e9.scheme;
    }(e8)) {
      if (Fe(e8.scheme)) {
        var i6 = ordinal($e[e8.scheme]), u4 = function(e9) {
          return i6(n6(e9));
        };
        return u4.scale = i6, u4;
      }
      if (He(e8.scheme)) {
        if (void 0 !== e8.size && (e8.size < 3 || e8.size > 11)) throw new Error("Invalid size '" + e8.size + "' for diverging color scheme '" + e8.scheme + "', must be between 3~11");
        var l5 = ordinal($e[e8.scheme][e8.size || 11]), a4 = function(e9) {
          return l5(n6(e9));
        };
        return a4.scale = l5, a4;
      }
      if (Je(e8.scheme)) {
        if (void 0 !== e8.size && (e8.size < 3 || e8.size > 9)) throw new Error("Invalid size '" + e8.size + "' for sequential color scheme '" + e8.scheme + "', must be between 3~9");
        var c8 = ordinal($e[e8.scheme][e8.size || 9]), s5 = function(e9) {
          return c8(n6(e9));
        };
        return s5.scale = c8, s5;
      }
    }
    throw new Error("Invalid colors, when using an object, you should either pass a 'datum' or a 'scheme' property");
  }
  return function() {
    return e8;
  };
};
var hr = function(e8, r6) {
  return (0, import_react20.useMemo)(function() {
    return gr(e8, r6);
  }, [e8, r6]);
};

// node_modules/@nivo/arcs/dist/nivo-arcs.mjs
init_src3();
function b4() {
  return b4 = Object.assign ? Object.assign.bind() : function(n6) {
    for (var t5 = 1; t5 < arguments.length; t5++) {
      var e8 = arguments[t5];
      for (var r6 in e8) ({}).hasOwnProperty.call(e8, r6) && (n6[r6] = e8[r6]);
    }
    return n6;
  }, b4.apply(null, arguments);
}
var L2 = { pointerEvents: "none" };
var P3 = function(t5) {
  var e8 = t5.label, r6 = t5.style, o6 = M();
  return (0, import_jsx_runtime5.jsx)(animated.g, { transform: r6.transform, opacity: r6.progress, style: L2, children: (0, import_jsx_runtime5.jsx)(b3, { textAnchor: "middle", dominantBaseline: "central", style: b4({}, o6.labels.text, { fill: r6.textColor }), children: e8 }) });
};
var W3 = { startAngle: { enter: function(n6) {
  return b4({}, n6, { endAngle: n6.startAngle });
}, update: function(n6) {
  return n6;
}, leave: function(n6) {
  return b4({}, n6, { startAngle: n6.endAngle });
} }, middleAngle: { enter: function(n6) {
  var t5 = n6.startAngle + (n6.endAngle - n6.startAngle) / 2;
  return b4({}, n6, { startAngle: t5, endAngle: t5 });
}, update: function(n6) {
  return n6;
}, leave: function(n6) {
  var t5 = n6.startAngle + (n6.endAngle - n6.startAngle) / 2;
  return b4({}, n6, { startAngle: t5, endAngle: t5 });
} }, endAngle: { enter: function(n6) {
  return b4({}, n6, { startAngle: n6.endAngle });
}, update: function(n6) {
  return n6;
}, leave: function(n6) {
  return b4({}, n6, { endAngle: n6.startAngle });
} }, innerRadius: { enter: function(n6) {
  return b4({}, n6, { outerRadius: n6.innerRadius });
}, update: function(n6) {
  return n6;
}, leave: function(n6) {
  return b4({}, n6, { innerRadius: n6.outerRadius });
} }, centerRadius: { enter: function(n6) {
  var t5 = n6.innerRadius + (n6.outerRadius - n6.innerRadius) / 2;
  return b4({}, n6, { innerRadius: t5, outerRadius: t5 });
}, update: function(n6) {
  return n6;
}, leave: function(n6) {
  var t5 = n6.innerRadius + (n6.outerRadius - n6.innerRadius) / 2;
  return b4({}, n6, { innerRadius: t5, outerRadius: t5 });
} }, outerRadius: { enter: function(n6) {
  return b4({}, n6, { innerRadius: n6.outerRadius });
}, update: function(n6) {
  return n6;
}, leave: function(n6) {
  return b4({}, n6, { outerRadius: n6.innerRadius });
} }, pushIn: { enter: function(n6) {
  return b4({}, n6, { innerRadius: n6.innerRadius - n6.outerRadius + n6.innerRadius, outerRadius: n6.innerRadius });
}, update: function(n6) {
  return n6;
}, leave: function(n6) {
  return b4({}, n6, { innerRadius: n6.outerRadius, outerRadius: n6.outerRadius + n6.outerRadius - n6.innerRadius });
} }, pushOut: { enter: function(n6) {
  return b4({}, n6, { innerRadius: n6.outerRadius, outerRadius: n6.outerRadius + n6.outerRadius - n6.innerRadius });
}, update: function(n6) {
  return n6;
}, leave: function(n6) {
  return b4({}, n6, { innerRadius: n6.innerRadius - n6.outerRadius + n6.innerRadius, outerRadius: n6.innerRadius });
} } };
var j3 = function(n6, t5) {
  return (0, import_react21.useMemo)(function() {
    var e8 = W3[n6];
    return { enter: function(n7) {
      return b4({ progress: 0 }, e8.enter(n7.arc), t5 ? t5.enter(n7) : {});
    }, update: function(n7) {
      return b4({ progress: 1 }, e8.update(n7.arc), t5 ? t5.update(n7) : {});
    }, leave: function(n7) {
      return b4({ progress: 0 }, e8.leave(n7.arc), t5 ? t5.leave(n7) : {});
    } };
  }, [n6, t5]);
};
var w2 = function(n6, t5) {
  var e8 = st(n6) - Math.PI / 2, r6 = n6.innerRadius + (n6.outerRadius - n6.innerRadius) * t5;
  return ft(e8, r6);
};
var B = function(n6) {
  return function(e8, r6, i6, a4) {
    return to2([e8, r6, i6, a4], function(t5, e9, r7, i7) {
      var a5 = w2({ startAngle: t5, endAngle: e9, innerRadius: r7, outerRadius: i7 }, n6);
      return "translate(" + a5.x + "," + a5.y + ")";
    });
  };
};
var S2 = function(n6, t5, r6, i6) {
  void 0 === t5 && (t5 = 0.5), void 0 === r6 && (r6 = "innerRadius");
  var a4 = Dr(), o6 = a4.animate, u4 = a4.config, s5 = j3(r6, i6);
  return { transition: useTransition(n6, { keys: function(n7) {
    return n7.id;
  }, initial: s5.update, from: s5.enter, enter: s5.update, update: s5.update, leave: s5.leave, config: u4, immediate: !o6 }), interpolate: B(t5) };
};
var q = function(n6) {
  var t5 = n6.center, e8 = n6.data, r6 = n6.transitionMode, a4 = n6.label, o6 = n6.radiusOffset, u4 = n6.skipAngle, l5 = n6.skipRadius, f3 = n6.textColor, p4 = n6.component, h2 = void 0 === p4 ? P3 : p4, v2 = bn(a4), R2 = M(), x3 = Ye(f3, R2), m3 = (0, import_react21.useMemo)(function() {
    return e8.filter(function(n7) {
      var t6 = Math.abs(ct(n7.arc.endAngle - n7.arc.startAngle)), e9 = Math.abs(n7.arc.outerRadius - n7.arc.innerRadius);
      return t6 >= u4 && e9 >= l5;
    });
  }, [e8, u4, l5]), y3 = S2(m3, o6, r6), k3 = y3.transition, C4 = y3.interpolate, b5 = h2;
  return (0, import_jsx_runtime5.jsx)("g", { transform: "translate(" + t5[0] + "," + t5[1] + ")", children: k3(function(n7, t6) {
    return (0, import_react21.createElement)(b5, { key: t6.id, datum: t6, label: v2(t6), style: { progress: n7.progress, transform: C4(n7.startAngle, n7.endAngle, n7.innerRadius, n7.outerRadius), textColor: x3(t6) } });
  }) });
};
var N2 = line_default().x(function(n6) {
  return n6.x;
}).y(function(n6) {
  return n6.y;
});
var rn = function(t5) {
  var e8 = t5.datum, r6 = t5.style, i6 = t5.onClick, a4 = t5.onMouseEnter, o6 = t5.onMouseMove, u4 = t5.onMouseLeave, l5 = (0, import_react21.useCallback)(function(n6) {
    return null == i6 ? void 0 : i6(e8, n6);
  }, [i6, e8]), d5 = (0, import_react21.useCallback)(function(n6) {
    return null == a4 ? void 0 : a4(e8, n6);
  }, [a4, e8]), c8 = (0, import_react21.useCallback)(function(n6) {
    return null == o6 ? void 0 : o6(e8, n6);
  }, [o6, e8]), g2 = (0, import_react21.useCallback)(function(n6) {
    return null == u4 ? void 0 : u4(e8, n6);
  }, [u4, e8]);
  return (0, import_jsx_runtime5.jsx)(animated.path, { d: r6.path, opacity: r6.opacity, fill: e8.fill || r6.color, stroke: r6.borderColor, strokeWidth: r6.borderWidth, onClick: i6 ? l5 : void 0, onMouseEnter: a4 ? d5 : void 0, onMouseMove: o6 ? c8 : void 0, onMouseLeave: u4 ? g2 : void 0, "data-testid": "arc." + e8.id });
};
var an = function(n6, e8, r6, i6, a4) {
  return to2([n6, e8, r6, i6], function(n7, t5, e9, r7) {
    return a4({ startAngle: n7, endAngle: t5, innerRadius: Math.max(0, e9), outerRadius: Math.max(0, r7) });
  });
};
var on = function(n6, t5, r6) {
  void 0 === t5 && (t5 = "innerRadius");
  var i6 = Dr(), a4 = i6.animate, o6 = i6.config, u4 = j3(t5, r6);
  return { transition: useTransition(n6, { keys: function(n7) {
    return n7.id;
  }, initial: u4.update, from: u4.enter, enter: u4.update, update: u4.update, leave: u4.leave, config: o6, immediate: !a4 }), interpolate: an };
};
var un2 = function(n6) {
  var t5 = n6.center, e8 = n6.data, r6 = n6.arcGenerator, a4 = n6.borderWidth, o6 = n6.borderColor, u4 = n6.onClick, l5 = n6.onMouseEnter, d5 = n6.onMouseMove, f3 = n6.onMouseLeave, g2 = n6.transitionMode, p4 = n6.component, h2 = void 0 === p4 ? rn : p4, v2 = M(), R2 = Ye(o6, v2), A3 = on(e8, g2, { enter: function(n7) {
    return { opacity: 0, color: n7.color, borderColor: R2(n7) };
  }, update: function(n7) {
    return { opacity: 1, color: n7.color, borderColor: R2(n7) };
  }, leave: function(n7) {
    return { opacity: 0, color: n7.color, borderColor: R2(n7) };
  } }), x3 = A3.transition, m3 = A3.interpolate, y3 = h2;
  return (0, import_jsx_runtime5.jsx)("g", { transform: "translate(" + t5[0] + "," + t5[1] + ")", children: x3(function(n7, t6) {
    return (0, import_react21.createElement)(y3, { key: t6.id, datum: t6, style: b4({}, n7, { borderWidth: a4, path: m3(n7.startAngle, n7.endAngle, n7.innerRadius, n7.outerRadius, r6) }), onClick: u4, onMouseEnter: l5, onMouseMove: d5, onMouseLeave: f3 });
  }) });
};
var fn2 = function(n6) {
  var t5 = void 0 === n6 ? {} : n6, e8 = t5.cornerRadius, r6 = void 0 === e8 ? 0 : e8, i6 = t5.padAngle, a4 = void 0 === i6 ? 0 : i6;
  return (0, import_react21.useMemo)(function() {
    return arc_default().innerRadius(function(n7) {
      return n7.innerRadius;
    }).outerRadius(function(n7) {
      return n7.outerRadius;
    }).cornerRadius(r6).padAngle(a4);
  }, [r6, a4]);
};

// node_modules/@nivo/sunburst/dist/nivo-sunburst.mjs
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
init_src6();
var import_cloneDeep = __toESM(require_cloneDeep(), 1);
var import_sortBy = __toESM(require_sortBy(), 1);
function W4() {
  return W4 = Object.assign ? Object.assign.bind() : function(e8) {
    for (var r6 = 1; r6 < arguments.length; r6++) {
      var o6 = arguments[r6];
      for (var i6 in o6) ({}).hasOwnProperty.call(o6, i6) && (e8[i6] = o6[i6]);
    }
    return e8;
  }, W4.apply(null, arguments);
}
function k2(e8, r6) {
  if (null == e8) return {};
  var o6 = {};
  for (var i6 in e8) if ({}.hasOwnProperty.call(e8, i6)) {
    if (-1 !== r6.indexOf(i6)) continue;
    o6[i6] = e8[i6];
  }
  return o6;
}
var x2 = { id: "id", value: "value", cornerRadius: 0, layers: ["arcs", "arcLabels"], colors: { scheme: "nivo" }, colorBy: "id", inheritColorFromParent: true, childColor: { from: "color" }, borderWidth: 1, borderColor: "white", enableArcLabels: false, arcLabel: "formattedValue", arcLabelsRadiusOffset: 0.5, arcLabelsSkipAngle: 0, arcLabelsSkipRadius: 0, arcLabelsTextColor: { theme: "labels.text.fill" }, animate: true, motionConfig: "gentle", transitionMode: "innerRadius", isInteractive: true, defs: [], fill: [], tooltip: function(e8) {
  var r6 = e8.id, o6 = e8.formattedValue, i6 = e8.color;
  return (0, import_jsx_runtime6.jsx)(T, { id: r6, value: o6, enableChip: true, color: i6 });
}, role: "img" };
var F2 = function(r6) {
  var o6 = r6.data, i6 = r6.id, a4 = void 0 === i6 ? x2.id : i6, l5 = r6.value, d5 = void 0 === l5 ? x2.value : l5, c8 = r6.valueFormat, s5 = r6.radius, v2 = r6.cornerRadius, f3 = void 0 === v2 ? x2.cornerRadius : v2, h2 = r6.colors, m3 = void 0 === h2 ? x2.colors : h2, p4 = r6.colorBy, W5 = void 0 === p4 ? x2.colorBy : p4, k3 = r6.inheritColorFromParent, F3 = void 0 === k3 ? x2.inheritColorFromParent : k3, I2 = r6.childColor, w4 = void 0 === I2 ? x2.childColor : I2, A3 = M(), O4 = hr(m3, W5), P5 = Ye(w4, A3), G2 = bn(a4), z5 = bn(d5), B2 = hn(c8), S3 = (0, import_react22.useMemo)(function() {
    var e8, r7 = (0, import_cloneDeep.default)(o6), i7 = hierarchy(r7).sum(z5), t5 = partition_default().size([2 * Math.PI, s5 * s5])(i7).descendants().slice(1), n6 = null != (e8 = i7.value) ? e8 : 0;
    return (0, import_sortBy.default)(t5, "depth").reduce(function(e9, r8) {
      var o7, i8 = G2(r8.data), t6 = r8.value, a5 = 100 * t6 / n6, l6 = r8.ancestors().map(function(e11) {
        return G2(e11.data);
      }), d6 = { startAngle: r8.x0, endAngle: r8.x1, innerRadius: Math.sqrt(r8.y0), outerRadius: Math.sqrt(r8.y1) };
      r8.parent && (o7 = e9.find(function(e11) {
        return e11.id === G2(r8.parent.data);
      }));
      var s6 = { id: i8, path: l6, value: t6, percentage: a5, formattedValue: c8 ? B2(t6) : a5.toFixed(2) + "%", color: "", arc: d6, data: r8.data, depth: r8.depth, height: r8.height };
      return F3 && o7 && s6.depth > 1 ? s6.color = P5(o7, s6) : s6.color = O4(s6), [].concat(e9, [s6]);
    }, []);
  }, [o6, s5, z5, G2, c8, B2, O4, F3, P5]);
  return { arcGenerator: fn2({ cornerRadius: f3 }), nodes: S3 };
};
var I = function(r6) {
  var o6 = r6.nodes, i6 = r6.arcGenerator, t5 = r6.centerX, n6 = r6.centerY, a4 = r6.radius;
  return (0, import_react22.useMemo)(function() {
    return { nodes: o6, arcGenerator: i6, centerX: t5, centerY: n6, radius: a4 };
  }, [o6, i6, t5, n6, a4]);
};
var w3 = function(o6) {
  var i6 = o6.center, t5 = o6.data, n6 = o6.arcGenerator, a4 = o6.borderWidth, l5 = o6.borderColor, d5 = o6.isInteractive, c8 = o6.onClick, s5 = o6.onMouseEnter, u4 = o6.onMouseMove, f3 = o6.onMouseLeave, h2 = o6.tooltip, b5 = o6.transitionMode, g2 = z2(), C4 = g2.showTooltipFromEvent, L4 = g2.hideTooltip, M4 = (0, import_react22.useMemo)(function() {
    if (d5) return function(e8, r6) {
      null == c8 || c8(e8, r6);
    };
  }, [d5, c8]), R2 = (0, import_react22.useMemo)(function() {
    if (d5) return function(e8, o7) {
      C4((0, import_react22.createElement)(h2, e8), o7), null == s5 || s5(e8, o7);
    };
  }, [d5, C4, h2, s5]), y3 = (0, import_react22.useMemo)(function() {
    if (d5) return function(e8, o7) {
      C4((0, import_react22.createElement)(h2, e8), o7), null == u4 || u4(e8, o7);
    };
  }, [d5, C4, h2, u4]), W5 = (0, import_react22.useMemo)(function() {
    if (d5) return function(e8, r6) {
      L4(), null == f3 || f3(e8, r6);
    };
  }, [d5, L4, f3]);
  return (0, import_jsx_runtime6.jsx)(un2, { center: i6, data: t5, arcGenerator: n6, borderWidth: a4, borderColor: l5, transitionMode: b5, onClick: M4, onMouseEnter: R2, onMouseMove: y3, onMouseLeave: W5 });
};
var A2 = ["isInteractive", "animate", "motionConfig", "theme", "renderWrapper"];
var O3 = function(o6) {
  var t5 = o6.data, n6 = o6.id, a4 = void 0 === n6 ? x2.id : n6, s5 = o6.value, u4 = void 0 === s5 ? x2.value : s5, v2 = o6.valueFormat, h2 = o6.cornerRadius, m3 = void 0 === h2 ? x2.cornerRadius : h2, b5 = o6.layers, g2 = void 0 === b5 ? x2.layers : b5, C4 = o6.colors, L4 = void 0 === C4 ? x2.colors : C4, M4 = o6.colorBy, R2 = void 0 === M4 ? x2.colorBy : M4, y3 = o6.inheritColorFromParent, W5 = void 0 === y3 ? x2.inheritColorFromParent : y3, k3 = o6.childColor, A3 = void 0 === k3 ? x2.childColor : k3, O4 = o6.borderWidth, P5 = void 0 === O4 ? x2.borderWidth : O4, G2 = o6.borderColor, z5 = void 0 === G2 ? x2.borderColor : G2, B2 = o6.margin, S3 = o6.width, j4 = o6.height, E2 = o6.enableArcLabels, H = void 0 === E2 ? x2.enableArcLabels : E2, T2 = o6.arcLabel, X = void 0 === T2 ? x2.arcLabel : T2, Y = o6.arcLabelsRadiusOffset, V2 = void 0 === Y ? x2.arcLabelsRadiusOffset : Y, q2 = o6.arcLabelsSkipAngle, K = void 0 === q2 ? x2.arcLabelsSkipAngle : q2, D = o6.arcLabelsSkipRadius, J = void 0 === D ? x2.arcLabelsSkipRadius : D, N3 = o6.arcLabelsTextColor, Q = void 0 === N3 ? x2.arcLabelsTextColor : N3, U = o6.arcLabelsComponent, Z = o6.defs, $ = void 0 === Z ? x2.defs : Z, _2 = o6.fill, ee = void 0 === _2 ? x2.fill : _2, re2 = o6.transitionMode, oe = void 0 === re2 ? x2.transitionMode : re2, ie = o6.isInteractive, te = void 0 === ie ? x2.isInteractive : ie, ne = o6.onClick, ae = o6.onMouseEnter, le = o6.onMouseLeave, de = o6.onMouseMove, ce = o6.tooltip, se = void 0 === ce ? x2.tooltip : ce, ue = o6.role, ve = void 0 === ue ? x2.role : ue, fe = o6.forwardedRef, he = cn(S3, j4, B2), me = he.innerHeight, pe = he.innerWidth, be = he.margin, ge = he.outerHeight, Ce2 = he.outerWidth, Le2 = (0, import_react22.useMemo)(function() {
    return { radius: Math.min(pe, me) / 2, centerX: pe / 2, centerY: me / 2 };
  }, [me, pe]), Me2 = Le2.centerX, Re2 = Le2.centerY, ye = Le2.radius, We2 = F2({ data: t5, id: a4, value: u4, valueFormat: v2, radius: ye, cornerRadius: m3, colors: L4, colorBy: R2, inheritColorFromParent: W5, childColor: A3 }), ke2 = We2.arcGenerator, xe = We2.nodes, Fe2 = Mn($, xe, ee, { colorKey: "color", targetKey: "fill" }), Ie = { arcs: null, arcLabels: null };
  g2.includes("arcs") && (Ie.arcs = (0, import_jsx_runtime6.jsx)(w3, { center: [Me2, Re2], data: xe, arcGenerator: ke2, borderWidth: P5, borderColor: z5, transitionMode: oe, isInteractive: te, tooltip: se, onClick: ne, onMouseEnter: ae, onMouseLeave: le, onMouseMove: de }, "arcs")), H && g2.includes("arcLabels") && (Ie.arcLabels = (0, import_jsx_runtime6.jsx)(q, { center: [Me2, Re2], data: xe, label: X, radiusOffset: V2, skipAngle: K, skipRadius: J, textColor: Q, transitionMode: oe, component: U }, "arcLabels"));
  var we2 = I({ nodes: xe, arcGenerator: ke2, centerX: Me2, centerY: Re2, radius: ye });
  return (0, import_jsx_runtime6.jsx)(Rt, { width: Ce2, height: ge, defs: Fe2, margin: be, role: ve, ref: fe, children: g2.map(function(e8, o7) {
    return void 0 !== Ie[e8] ? Ie[e8] : "function" == typeof e8 ? (0, import_jsx_runtime6.jsx)(import_react22.Fragment, { children: (0, import_react22.createElement)(e8, we2) }, o7) : null;
  }) });
};
var P4 = (0, import_react22.forwardRef)(function(e8, r6) {
  var o6 = e8.isInteractive, i6 = void 0 === o6 ? x2.isInteractive : o6, t5 = e8.animate, n6 = void 0 === t5 ? x2.animate : t5, l5 = e8.motionConfig, d5 = void 0 === l5 ? x2.motionConfig : l5, c8 = e8.theme, s5 = e8.renderWrapper, u4 = k2(e8, A2);
  return (0, import_jsx_runtime6.jsx)(Fr, { isInteractive: i6, animate: n6, motionConfig: d5, theme: c8, renderWrapper: s5, children: (0, import_jsx_runtime6.jsx)(O3, W4({}, u4, { isInteractive: i6, forwardedRef: r6 })) });
});
var G = ["defaultWidth", "defaultHeight", "onResize", "debounceResize"];
var z4 = (0, import_react22.forwardRef)(function(e8, r6) {
  var o6 = e8.defaultWidth, i6 = e8.defaultHeight, t5 = e8.onResize, n6 = e8.debounceResize, a4 = k2(e8, G);
  return (0, import_jsx_runtime6.jsx)($r, { defaultWidth: o6, defaultHeight: i6, onResize: t5, debounceResize: n6, children: function(e9) {
    var o7 = e9.width, i7 = e9.height;
    return (0, import_jsx_runtime6.jsx)(P4, W4({}, a4, { width: o7, height: i7, ref: r6 }));
  } });
});
export {
  z4 as ResponsiveSunburst,
  P4 as Sunburst,
  x2 as defaultProps,
  F2 as useSunburst,
  I as useSunburstLayerContext
};
//# sourceMappingURL=@nivo_sunburst.js.map
